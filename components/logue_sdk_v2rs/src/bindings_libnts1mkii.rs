/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.1.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __CM7_CMSIS_VERSION_MAIN: u32 = 4;
pub const __CM7_CMSIS_VERSION_SUB: u32 = 30;
pub const __CM7_CMSIS_VERSION: u32 = 262174;
pub const __CORTEX_M: u32 = 7;
pub const __FPU_USED: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const _MATH_ERRHANDLING_ERRNO: u32 = 1;
pub const _MATH_ERRHANDLING_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_TWOPI: f64 = 6.283185307179586;
pub const M_SQRTPI: f64 = 1.772453850905516;
pub const M_SQRT3: f64 = 1.7320508075688772;
pub const M_IVLN10: f64 = 0.4342944819032518;
pub const M_LOG2_E: f64 = 0.6931471805599453;
pub const DELTA_Q31: u32 = 256;
pub const DELTA_Q15: u32 = 5;
pub const INDEX_MASK: u32 = 63;
pub const PI: f64 = 3.14159265358979;
pub const FAST_MATH_TABLE_SIZE: u32 = 512;
pub const FAST_MATH_Q31_SHIFT: u32 = 22;
pub const FAST_MATH_Q15_SHIFT: u32 = 6;
pub const CONTROLLER_Q31_SHIFT: u32 = 23;
pub const TABLE_SIZE: u32 = 256;
pub const TABLE_SPACING_Q31: u32 = 4194304;
pub const TABLE_SPACING_Q15: u32 = 128;
pub const INPUT_SPACING: u32 = 11930465;
pub const M_HALPI_Q1_14: u32 = 25736;
pub const M_HALPI_Q1_30: u32 = 1686629713;
pub const M_PI_Q2_13: u32 = 25736;
pub const M_PI_Q2_29: u32 = 1686629713;
pub const M_1OVERPI_Q15: u32 = 10430;
pub const M_1OVERPI_Q31: u32 = 683565276;
pub const M_TWOPI_Q3_12: u32 = 25736;
pub const M_TWOPI_Q3_28: u32 = 1686629713;
pub const M_1OVER48K_Q31: u32 = 44739;
pub const M_1OVER44K_Q31: u32 = 48696;
pub const M_1OVER22K_Q31: u32 = 97392;
pub const M_4_PI: f64 = 1.2732395447351628;
pub const M_1_TWOPI: f64 = 0.15915494309189535;
pub const M_4_PI2: f64 = 0.4052847345693511;
pub const M_1_SQRT2: f64 = 0.7071067811865475;
pub const F32_FRAC_MASK: u32 = 8388607;
pub const F32_EXP_MASK: u32 = 4286578688;
pub const F32_SIGN_MASK: u32 = 2147483648;
pub const k_samplerate: u32 = 48000;
pub const k_midi_to_hz_size: u32 = 152;
pub const k_note_mod_fscale: f64 = 0.00392156862745098;
pub const k_note_max_hz: f64 = 23679.643054;
pub const k_wt_sine_size_exp: u32 = 7;
pub const k_wt_sine_size: u32 = 128;
pub const k_wt_sine_u32shift: u32 = 24;
pub const k_wt_sine_mask: u32 = 127;
pub const k_wt_sine_lut_size: u32 = 129;
pub const k_wt_saw_size_exp: u32 = 7;
pub const k_wt_saw_size: u32 = 128;
pub const k_wt_saw_u32shift: u32 = 24;
pub const k_wt_saw_mask: u32 = 127;
pub const k_wt_saw_lut_size: u32 = 129;
pub const k_wt_saw_notes_cnt: u32 = 7;
pub const k_wt_saw_lut_tsize: u32 = 903;
pub const k_wt_sqr_size_exp: u32 = 7;
pub const k_wt_sqr_size: u32 = 128;
pub const k_wt_sqr_u32shift: u32 = 24;
pub const k_wt_sqr_mask: u32 = 127;
pub const k_wt_sqr_lut_size: u32 = 129;
pub const k_wt_sqr_notes_cnt: u32 = 7;
pub const k_wt_sqr_lut_tsize: u32 = 903;
pub const k_wt_par_size_exp: u32 = 7;
pub const k_wt_par_size: u32 = 128;
pub const k_wt_par_u32shift: u32 = 24;
pub const k_wt_par_mask: u32 = 127;
pub const k_wt_par_lut_size: u32 = 129;
pub const k_wt_par_notes_cnt: u32 = 7;
pub const k_wt_par_lut_tsize: u32 = 903;
pub const k_waves_size_exp: u32 = 7;
pub const k_waves_size: u32 = 128;
pub const k_waves_u32shift: u32 = 24;
pub const k_waves_mask: u32 = 127;
pub const k_waves_lut_size: u32 = 129;
pub const k_waves_a_cnt: u32 = 16;
pub const k_waves_b_cnt: u32 = 16;
pub const k_waves_c_cnt: u32 = 14;
pub const k_waves_d_cnt: u32 = 13;
pub const k_waves_e_cnt: u32 = 15;
pub const k_waves_f_cnt: u32 = 16;
pub const k_log_size_exp: u32 = 8;
pub const k_log_size: u32 = 256;
pub const k_log_mask: u32 = 255;
pub const k_log_lut_size: u32 = 257;
pub const k_tanpi_size_exp: u32 = 8;
pub const k_tanpi_size: u32 = 256;
pub const k_tanpi_mask: u32 = 255;
pub const k_tanpi_range_recip: f64 = 2.04081632653061;
pub const k_tanpi_lut_size: u32 = 257;
pub const k_sqrtm2log_size_exp: u32 = 8;
pub const k_sqrtm2log_size: u32 = 256;
pub const k_sqrtm2log_mask: u32 = 255;
pub const k_sqrtm2log_base: f64 = 0.005;
pub const k_sqrtm2log_range_recip: f64 = 1.00502512562814;
pub const k_sqrtm2log_lut_size: u32 = 257;
pub const k_cubicsat_size_exp: u32 = 7;
pub const k_cubicsat_size: u32 = 128;
pub const k_cubicsat_mask: u32 = 127;
pub const k_cubicsat_lut_size: u32 = 129;
pub const k_schetzen_size_exp: u32 = 7;
pub const k_schetzen_size: u32 = 128;
pub const k_schetzen_mask: u32 = 127;
pub const k_schetzen_lut_size: u32 = 129;
pub const k_bitres_size_exp: u32 = 7;
pub const k_bitres_size: u32 = 128;
pub const k_bitres_mask: u32 = 127;
pub const k_bitres_lut_size: u32 = 129;
pub const k_pow2_size_exp: u32 = 8;
pub const k_pow2_size: u32 = 256;
pub const k_pow2_scale: f64 = 85.3333333333333;
pub const k_pow2_mask: u32 = 255;
pub const k_pow2_lut_size: u32 = 257;
pub const UNIT_TARGET_PLATFORM_MASK: u32 = 32512;
pub const UNIT_TARGET_MODULE_MASK: u32 = 127;
pub const UNIT_API_MAJOR_MASK: u32 = 8323072;
pub const UNIT_API_MINOR_MASK: u32 = 32512;
pub const UNIT_API_PATCH_MASK: u32 = 127;
pub const UNIT_MAX_PARAM_COUNT: u32 = 11;
pub const UNIT_PARAM_NAME_LEN: u32 = 21;
pub const UNIT_PARAM_NAME_SIZE: u32 = 22;
pub const UNIT_NAME_LEN: u32 = 19;
pub const UNIT_NAME_SIZE: u32 = 20;
pub const UNIT_DELFX_MAX_PARAM_COUNT: u32 = 11;
pub const UNIT_MODFX_MAX_PARAM_COUNT: u32 = 10;
pub const UNIT_OSC_MAX_PARAM_COUNT: u32 = 10;
pub const UNIT_REVFX_MAX_PARAM_COUNT: u32 = 11;
pub type __int8_t = core::ffi::c_schar;
pub type __uint8_t = core::ffi::c_uchar;
pub type __int16_t = core::ffi::c_short;
pub type __uint16_t = core::ffi::c_ushort;
pub type __int32_t = core::ffi::c_int;
pub type __uint32_t = core::ffi::c_uint;
pub type __int64_t = core::ffi::c_longlong;
pub type __uint64_t = core::ffi::c_ulonglong;
pub type __int_least8_t = core::ffi::c_schar;
pub type __uint_least8_t = core::ffi::c_uchar;
pub type __int_least16_t = core::ffi::c_short;
pub type __uint_least16_t = core::ffi::c_ushort;
pub type __int_least32_t = core::ffi::c_int;
pub type __uint_least32_t = core::ffi::c_uint;
pub type __int_least64_t = core::ffi::c_longlong;
pub type __uint_least64_t = core::ffi::c_ulonglong;
pub type __intmax_t = core::ffi::c_longlong;
pub type __uintmax_t = core::ffi::c_ulonglong;
pub type __intptr_t = core::ffi::c_int;
pub type __uintptr_t = core::ffi::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = core::ffi::c_schar;
pub type uint_fast8_t = core::ffi::c_uchar;
pub type int_fast16_t = core::ffi::c_short;
pub type uint_fast16_t = core::ffi::c_ushort;
pub type int_fast32_t = core::ffi::c_int;
pub type uint_fast32_t = core::ffi::c_uint;
pub type int_fast64_t = core::ffi::c_longlong;
pub type uint_fast64_t = core::ffi::c_ulonglong;
pub type wchar_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type wint_t = core::ffi::c_int;
pub type __blkcnt_t = core::ffi::c_long;
pub type __blksize_t = core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = core::ffi::c_long;
pub type __pid_t = core::ffi::c_int;
pub type __dev_t = core::ffi::c_short;
pub type __uid_t = core::ffi::c_ushort;
pub type __gid_t = core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = core::ffi::c_long;
pub type _fpos_t = core::ffi::c_long;
pub type __size_t = core::ffi::c_uint;
pub type _ssize_t = core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _iconv_t = *mut core::ffi::c_void;
pub type __clock_t = core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = core::ffi::c_ulong;
pub type __timer_t = core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = core::ffi::c_int;
pub type __nlink_t = core::ffi::c_ushort;
pub type __suseconds_t = core::ffi::c_long;
pub type __useconds_t = core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: core::ffi::c_int,
    pub _maxwds: core::ffi::c_int,
    pub _sign: core::ffi::c_int,
    pub _wds: core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: core::ffi::c_int,
    pub __tm_min: core::ffi::c_int,
    pub __tm_hour: core::ffi::c_int,
    pub __tm_mday: core::ffi::c_int,
    pub __tm_mon: core::ffi::c_int,
    pub __tm_year: core::ffi::c_int,
    pub __tm_wday: core::ffi::c_int,
    pub __tm_yday: core::ffi::c_int,
    pub __tm_isdst: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut core::ffi::c_uchar,
    pub _size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut core::ffi::c_uchar,
    pub _r: core::ffi::c_int,
    pub _w: core::ffi::c_int,
    pub _flags: core::ffi::c_short,
    pub _file: core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: core::ffi::c_int,
    pub _cookie: *mut core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *mut core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *const core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: _fpos_t,
            arg4: core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut core::ffi::c_uchar,
    pub _ur: core::ffi::c_int,
    pub _ubuf: [core::ffi::c_uchar; 3usize],
    pub _nbuf: [core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [core::ffi::c_ushort; 3usize],
    pub _mult: [core::ffi::c_ushort; 3usize],
    pub _add: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: core::ffi::c_int,
    pub _emergency: [core::ffi::c_char; 25usize],
    pub _unspecified_locale_info: core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: core::ffi::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: core::ffi::c_int,
    pub _cvtbuf: *mut core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: core::ffi::c_uint,
    pub _strtok_last: *mut core::ffi::c_char,
    pub _asctime_buf: [core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: core::ffi::c_int,
    pub _rand_next: core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [core::ffi::c_char; 8usize],
    pub _signal_buf: [core::ffi::c_char; 24usize],
    pub _getdate_err: core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut core::ffi::c_uchar; 30usize],
    pub _nmalloc: [core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const core::ffi::c_void, arg2: *mut core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: core::ffi::c_longlong) -> core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: core::ffi::c_longlong) -> core::ffi::c_int;
}
extern "C" {
    pub fn index(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: locale_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strerror(arg1: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: locale_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: core::ffi::c_int, arg2: locale_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_int,
        arg4: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: core::ffi::c_int,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_int,
        arg4: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strnlen(arg1: *const core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: core::ffi::c_int) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn finitel(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn isinff(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn isnanf(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn isinf(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn isnan(arg1: f64) -> core::ffi::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn __isinfd(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn __isnanf(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn __isnand(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn __signbitf(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn __signbitd(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: core::ffi::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: core::ffi::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> core::ffi::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> core::ffi::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> core::ffi::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> core::ffi::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> core::ffi::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: core::ffi::c_long) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> core::ffi::c_long;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> core::ffi::c_longlong;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: core::ffi::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: core::ffi::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: core::ffi::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: core::ffi::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __signgam() -> *mut core::ffi::c_int;
}
#[doc = "< No error"]
pub const arm_status_ARM_MATH_SUCCESS: arm_status = 0;
#[doc = "< One or more arguments are incorrect"]
pub const arm_status_ARM_MATH_ARGUMENT_ERROR: arm_status = -1;
#[doc = "< Length of data buffer is incorrect"]
pub const arm_status_ARM_MATH_LENGTH_ERROR: arm_status = -2;
#[doc = "< Size of matrices is not compatible with the operation."]
pub const arm_status_ARM_MATH_SIZE_MISMATCH: arm_status = -3;
#[doc = "< Not-a-number (NaN) or infinity is generated"]
pub const arm_status_ARM_MATH_NANINF: arm_status = -4;
#[doc = "< Generated by matrix inversion if the input matrix is singular and cannot be inverted."]
pub const arm_status_ARM_MATH_SINGULAR: arm_status = -5;
#[doc = "< Test Failed"]
pub const arm_status_ARM_MATH_TEST_FAILURE: arm_status = -6;
#[doc = " @brief Error status returned by some functions in the library."]
pub type arm_status = core::ffi::c_int;
#[doc = " @brief 8-bit fractional data type in 1.7 format."]
pub type q7_t = i8;
#[doc = " @brief 16-bit fractional data type in 1.15 format."]
pub type q15_t = i16;
#[doc = " @brief 32-bit fractional data type in 1.31 format."]
pub type q31_t = i32;
#[doc = " @brief 64-bit fractional data type in 1.63 format."]
pub type q63_t = i64;
#[doc = " @brief 32-bit floating-point type definition."]
pub type float32_t = f32;
#[doc = " @brief 64-bit floating-point type definition."]
pub type float64_t = f64;
#[doc = " @brief Instance structure for the Q7 FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_instance_q7 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q7_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q7_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q7() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_instance_q7> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q7>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q7>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q7))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_instance_q15 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q15>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_instance_q31 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q31>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_instance_f32 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_f32>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q7 FIR filter.\n @param[in]  S          points to an instance of the Q7 FIR filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q7(
        S: *const arm_fir_instance_q7,
        pSrc: *mut q7_t,
        pDst: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q7 FIR filter.\n @param[in,out] S          points to an instance of the Q7 FIR structure.\n @param[in]     numTaps    Number of filter coefficients in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of samples that are processed."]
    pub fn arm_fir_init_q7(
        S: *mut arm_fir_instance_q7,
        numTaps: u16,
        pCoeffs: *mut q7_t,
        pState: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR filter.\n @param[in]  S          points to an instance of the Q15 FIR structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q15(
        S: *const arm_fir_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.\n @param[in]  S          points to an instance of the Q15 FIR filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_fast_q15(
        S: *const arm_fir_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR filter.\n @param[in,out] S          points to an instance of the Q15 FIR filter structure.\n @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greater than or equal to 4.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of samples that are processed at a time.\n @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if\n <code>numTaps</code> is not a supported value."]
    pub fn arm_fir_init_q15(
        S: *mut arm_fir_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR filter.\n @param[in]  S          points to an instance of the Q31 FIR filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q31(
        S: *const arm_fir_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.\n @param[in]  S          points to an instance of the Q31 FIR structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_fast_q31(
        S: *const arm_fir_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR filter.\n @param[in,out] S          points to an instance of the Q31 FIR structure.\n @param[in]     numTaps    Number of filter coefficients in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of samples that are processed at a time."]
    pub fn arm_fir_init_q31(
        S: *mut arm_fir_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR filter.\n @param[in]  S          points to an instance of the floating-point FIR structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_f32(
        S: *const arm_fir_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR filter.\n @param[in,out] S          points to an instance of the floating-point FIR filter structure.\n @param[in]     numTaps    Number of filter coefficients in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of samples that are processed at a time."]
    pub fn arm_fir_init_f32(
        S: *mut arm_fir_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_casd_df1_inst_q15 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: i8,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q15_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< Additional shift, in bits, applied to each output sample."]
    pub postShift: i8,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_casd_df1_inst_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(postShift)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_casd_df1_inst_q31 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u32,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q31_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< Additional shift, in bits, applied to each output sample."]
    pub postShift: u8,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_casd_df1_inst_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(postShift)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_casd_df1_inst_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u32,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_casd_df1_inst_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_f32>(),
        12usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 Biquad cascade filter.\n @param[in]  S          points to an instance of the Q15 Biquad cascade structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_q15(
        S: *const arm_biquad_casd_df1_inst_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 Biquad cascade filter.\n @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cascade_df1_init_q15(
        S: *mut arm_biquad_casd_df1_inst_q15,
        numStages: u8,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        postShift: i8,
    );
}
extern "C" {
    #[doc = " @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.\n @param[in]  S          points to an instance of the Q15 Biquad cascade structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_fast_q15(
        S: *const arm_biquad_casd_df1_inst_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 Biquad cascade filter\n @param[in]  S          points to an instance of the Q31 Biquad cascade structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_q31(
        S: *const arm_biquad_casd_df1_inst_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.\n @param[in]  S          points to an instance of the Q31 Biquad cascade structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_fast_q31(
        S: *const arm_biquad_casd_df1_inst_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 Biquad cascade filter.\n @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cascade_df1_init_q31(
        S: *mut arm_biquad_casd_df1_inst_q31,
        numStages: u8,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        postShift: i8,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point Biquad cascade filter.\n @param[in]  S          points to an instance of the floating-point Biquad cascade structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_f32(
        S: *const arm_biquad_casd_df1_inst_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point Biquad cascade filter.\n @param[in,out] S          points to an instance of the floating-point Biquad cascade structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df1_init_f32(
        S: *mut arm_biquad_casd_df1_inst_f32,
        numStages: u8,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the floating-point matrix structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_matrix_instance_f32 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_matrix_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_f32>(),
        8usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point matrix structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_matrix_instance_f64 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut float64_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_f64() {
    const UNINIT: ::core::mem::MaybeUninit<arm_matrix_instance_f64> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_f64>(),
        8usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_f64))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_f64>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_f64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 matrix structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_matrix_instance_q15 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_matrix_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q15>(),
        8usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 matrix structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_matrix_instance_q31 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_matrix_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q31>(),
        8usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(pData)
        )
    );
}
extern "C" {
    #[doc = " @brief Floating-point matrix addition.\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15 matrix addition.\n @param[in]   pSrcA  points to the first input matrix structure\n @param[in]   pSrcB  points to the second input matrix structure\n @param[out]  pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31 matrix addition.\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Floating-point, complex, matrix multiplication.\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15, complex,  matrix multiplication.\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pScratch: *mut q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31, complex, matrix multiplication.\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Floating-point matrix transpose.\n @param[in]  pSrc  points to the input matrix\n @param[out] pDst  points to the output matrix\n @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>\n or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_f32(
        pSrc: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15 matrix transpose.\n @param[in]  pSrc  points to the input matrix\n @param[out] pDst  points to the output matrix\n @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>\n or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q15(
        pSrc: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31 matrix transpose.\n @param[in]  pSrc  points to the input matrix\n @param[out] pDst  points to the output matrix\n @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>\n or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q31(
        pSrc: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Floating-point matrix multiplication\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15 matrix multiplication\n @param[in]  pSrcA   points to the first input matrix structure\n @param[in]  pSrcB   points to the second input matrix structure\n @param[out] pDst    points to output matrix structure\n @param[in]  pState  points to the array for storing intermediate results\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pState: *mut q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA   points to the first input matrix structure\n @param[in]  pSrcB   points to the second input matrix structure\n @param[out] pDst    points to output matrix structure\n @param[in]  pState  points to the array for storing intermediate results\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_fast_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pState: *mut q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_fast_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Floating-point matrix subtraction\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15 matrix subtraction\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31 matrix subtraction\n @param[in]  pSrcA  points to the first input matrix structure\n @param[in]  pSrcB  points to the second input matrix structure\n @param[out] pDst   points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Floating-point matrix scaling.\n @param[in]  pSrc   points to the input matrix\n @param[in]  scale  scale factor\n @param[out] pDst   points to the output matrix\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_f32(
        pSrc: *const arm_matrix_instance_f32,
        scale: float32_t,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q15 matrix scaling.\n @param[in]  pSrc        points to input matrix\n @param[in]  scaleFract  fractional portion of the scale factor\n @param[in]  shift       number of bits to shift the result by\n @param[out] pDst        points to output matrix\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_q15(
        pSrc: *const arm_matrix_instance_q15,
        scaleFract: q15_t,
        shift: i32,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Q31 matrix scaling.\n @param[in]  pSrc        points to input matrix\n @param[in]  scaleFract  fractional portion of the scale factor\n @param[in]  shift       number of bits to shift the result by\n @param[out] pDst        points to output matrix structure\n @return     The function returns either\n <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_q31(
        pSrc: *const arm_matrix_instance_q31,
        scaleFract: q31_t,
        shift: i32,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief  Q31 matrix initialization.\n @param[in,out] S         points to an instance of the floating-point matrix structure.\n @param[in]     nRows     number of rows in the matrix.\n @param[in]     nColumns  number of columns in the matrix.\n @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_q31(
        S: *mut arm_matrix_instance_q31,
        nRows: u16,
        nColumns: u16,
        pData: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief  Q15 matrix initialization.\n @param[in,out] S         points to an instance of the floating-point matrix structure.\n @param[in]     nRows     number of rows in the matrix.\n @param[in]     nColumns  number of columns in the matrix.\n @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_q15(
        S: *mut arm_matrix_instance_q15,
        nRows: u16,
        nColumns: u16,
        pData: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point matrix initialization.\n @param[in,out] S         points to an instance of the floating-point matrix structure.\n @param[in]     nRows     number of rows in the matrix.\n @param[in]     nColumns  number of columns in the matrix.\n @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_f32(
        S: *mut arm_matrix_instance_f32,
        nRows: u16,
        nColumns: u16,
        pData: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the Q15 PID Control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_pid_instance_q15 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: q15_t,
    #[doc = "< The derived gain A1 = -Kp - 2Kd | Kd."]
    pub A1: q31_t,
    #[doc = "< The state array of length 3."]
    pub state: [q15_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: q15_t,
    #[doc = "< The integral gain."]
    pub Ki: q15_t,
    #[doc = "< The derivative gain."]
    pub Kd: q15_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_pid_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_q15>(),
        20usize,
        concat!("Size of: ", stringify!(arm_pid_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Kp) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ki) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Kd) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Kd)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 PID Control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_pid_instance_q31 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: q31_t,
    #[doc = "< The derived gain, A1 = -Kp - 2Kd."]
    pub A1: q31_t,
    #[doc = "< The derived gain, A2 = Kd ."]
    pub A2: q31_t,
    #[doc = "< The state array of length 3."]
    pub state: [q31_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: q31_t,
    #[doc = "< The integral gain."]
    pub Ki: q31_t,
    #[doc = "< The derivative gain."]
    pub Kd: q31_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_pid_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_q31>(),
        36usize,
        concat!("Size of: ", stringify!(arm_pid_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Kp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ki) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Kd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Kd)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point PID Control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_pid_instance_f32 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: float32_t,
    #[doc = "< The derived gain, A1 = -Kp - 2Kd."]
    pub A1: float32_t,
    #[doc = "< The derived gain, A2 = Kd ."]
    pub A2: float32_t,
    #[doc = "< The state array of length 3."]
    pub state: [float32_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: float32_t,
    #[doc = "< The integral gain."]
    pub Ki: float32_t,
    #[doc = "< The derivative gain."]
    pub Kd: float32_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_pid_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_f32>(),
        36usize,
        concat!("Size of: ", stringify!(arm_pid_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).A2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Kp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ki) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Kd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Kd)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point PID Control.\n @param[in,out] S               points to an instance of the PID structure.\n @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_f32(S: *mut arm_pid_instance_f32, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the floating-point PID Control.\n @param[in,out] S  is an instance of the floating-point PID Control structure"]
    pub fn arm_pid_reset_f32(S: *mut arm_pid_instance_f32);
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 PID Control.\n @param[in,out] S               points to an instance of the Q15 PID structure.\n @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_q31(S: *mut arm_pid_instance_q31, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the Q31 PID Control.\n @param[in,out] S   points to an instance of the Q31 PID Control structure"]
    pub fn arm_pid_reset_q31(S: *mut arm_pid_instance_q31);
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 PID Control.\n @param[in,out] S               points to an instance of the Q15 PID structure.\n @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_q15(S: *mut arm_pid_instance_q15, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the Q15 PID Control.\n @param[in,out] S  points to an instance of the q15 PID Control structure"]
    pub fn arm_pid_reset_q15(S: *mut arm_pid_instance_q15);
}
#[doc = " @brief Instance structure for the floating-point Linear Interpolate function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_linear_interp_instance_f32 {
    #[doc = "< nValues"]
    pub nValues: u32,
    #[doc = "< x1"]
    pub x1: float32_t,
    #[doc = "< xSpacing"]
    pub xSpacing: float32_t,
    #[doc = "< pointer to the table of Y values"]
    pub pYData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_linear_interp_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_linear_interp_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_linear_interp_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_linear_interp_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_linear_interp_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_linear_interp_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nValues) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(nValues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xSpacing) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(xSpacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pYData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(pYData)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point bilinear interpolation function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_bilinear_interp_instance_f32 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_bilinear_interp_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_f32>(),
        8usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_f32>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_bilinear_interp_instance_f32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_f32),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_f32),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_f32),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 bilinear interpolation function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_bilinear_interp_instance_q31 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_bilinear_interp_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_q31>(),
        8usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_q31>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_bilinear_interp_instance_q31)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q31),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q31),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q31),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 bilinear interpolation function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_bilinear_interp_instance_q15 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_bilinear_interp_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_q15>(),
        8usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_q15>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_bilinear_interp_instance_q15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q15),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q15),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q15),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 bilinear interpolation function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_bilinear_interp_instance_q7 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut q7_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_q7() {
    const UNINIT: ::core::mem::MaybeUninit<arm_bilinear_interp_instance_q7> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_q7>(),
        8usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_q7>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_bilinear_interp_instance_q7))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numRows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q7),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numCols) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q7),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q7),
            "::",
            stringify!(pData)
        )
    );
}
extern "C" {
    #[doc = " @brief Q7 vector multiplication.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q7(pSrcA: *mut q7_t, pSrcB: *mut q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector multiplication.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q15(pSrcA: *mut q15_t, pSrcB: *mut q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector multiplication.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q31(pSrcA: *mut q31_t, pSrcB: *mut q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector multiplication.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_f32(
        pSrcA: *mut float32_t,
        pSrcB: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_radix2_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Sin twiddle factor table."]
    pub pTwiddle: *mut q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *mut u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_radix2_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefModifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevFactor) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_q15(
        S: *mut arm_cfft_radix2_instance_q15,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_cfft_radix2_q15(S: *const arm_cfft_radix2_instance_q15, pSrc: *mut q15_t);
}
#[doc = " @brief Instance structure for the Q15 CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_radix4_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *mut q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *mut u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_radix4_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefModifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevFactor) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_init_q15(
        S: *mut arm_cfft_radix4_instance_q15,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_cfft_radix4_q15(S: *const arm_cfft_radix4_instance_q15, pSrc: *mut q15_t);
}
#[doc = " @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_radix2_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *mut q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *mut u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_radix2_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefModifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevFactor) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_q31(
        S: *mut arm_cfft_radix2_instance_q31,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_cfft_radix2_q31(S: *const arm_cfft_radix2_instance_q31, pSrc: *mut q31_t);
}
#[doc = " @brief Instance structure for the Q31 CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_radix4_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *mut q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *mut u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_radix4_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefModifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevFactor) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_q31(S: *const arm_cfft_radix4_instance_q31, pSrc: *mut q31_t);
}
extern "C" {
    pub fn arm_cfft_radix4_init_q31(
        S: *mut arm_cfft_radix4_instance_q31,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status;
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_radix2_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *mut float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *mut u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
    #[doc = "< value of 1/fftLen."]
    pub onebyfftLen: float32_t,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_radix2_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_f32>(),
        20usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefModifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevFactor) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(bitRevFactor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).onebyfftLen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(onebyfftLen)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_f32(
        S: *mut arm_cfft_radix2_instance_f32,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_cfft_radix2_f32(S: *const arm_cfft_radix2_instance_f32, pSrc: *mut float32_t);
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_radix4_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *mut float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *mut u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
    #[doc = "< value of 1/fftLen."]
    pub onebyfftLen: float32_t,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_radix4_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_f32>(),
        20usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefModifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevFactor) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(bitRevFactor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).onebyfftLen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(onebyfftLen)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_init_f32(
        S: *mut arm_cfft_radix4_instance_f32,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_cfft_radix4_f32(S: *const arm_cfft_radix4_instance_f32, pSrc: *mut float32_t);
}
#[doc = " @brief Instance structure for the fixed-point CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_q15(
        S: *const arm_cfft_instance_q15,
        p1: *mut q15_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the fixed-point CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_q31(
        S: *const arm_cfft_instance_q31,
        p1: *mut q31_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_cfft_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_cfft_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBitRevTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitRevLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_f32(
        S: *const arm_cfft_instance_f32,
        p1: *mut float32_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the Q15 RFFT/RIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_rfft_instance_q15 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *mut q15_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *mut q15_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *const arm_cfft_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_rfft_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLenReal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlagR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlagR) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefRModifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleAReal) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleBReal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCfft) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_q15(
        S: *mut arm_rfft_instance_q15,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_rfft_q15(S: *const arm_rfft_instance_q15, pSrc: *mut q15_t, pDst: *mut q15_t);
}
#[doc = " @brief Instance structure for the Q31 RFFT/RIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_rfft_instance_q31 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *mut q31_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *mut q31_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *const arm_cfft_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_rfft_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLenReal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlagR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlagR) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefRModifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleAReal) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleBReal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCfft) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_q31(
        S: *mut arm_rfft_instance_q31,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_rfft_q31(S: *const arm_rfft_instance_q31, pSrc: *mut q31_t, pDst: *mut q31_t);
}
#[doc = " @brief Instance structure for the floating-point RFFT/RIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_rfft_instance_f32 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< length of the complex FFT."]
    pub fftLenBy2: u16,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *mut float32_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *mut float32_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_rfft_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLenReal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLenBy2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(fftLenBy2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifftFlagR) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitReverseFlagR) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).twidCoefRModifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleAReal) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleBReal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCfft) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_f32(
        S: *mut arm_rfft_instance_f32,
        S_CFFT: *mut arm_cfft_radix4_instance_f32,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status;
}
extern "C" {
    pub fn arm_rfft_f32(
        S: *const arm_rfft_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the floating-point RFFT/RIFFT function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_rfft_fast_instance_f32 {
    #[doc = "< Internal CFFT structure."]
    pub Sint: arm_cfft_instance_f32,
    #[doc = "< length of the real sequence"]
    pub fftLenRFFT: u16,
    #[doc = "< Twiddle factors real stage"]
    pub pTwiddleRFFT: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_rfft_fast_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_rfft_fast_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_fast_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_rfft_fast_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_fast_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_rfft_fast_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(Sint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fftLenRFFT) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(fftLenRFFT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddleRFFT) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(pTwiddleRFFT)
        )
    );
}
extern "C" {
    pub fn arm_rfft_fast_init_f32(S: *mut arm_rfft_fast_instance_f32, fftLen: u16) -> arm_status;
}
extern "C" {
    pub fn arm_rfft_fast_f32(
        S: *mut arm_rfft_fast_instance_f32,
        p: *mut float32_t,
        pOut: *mut float32_t,
        ifftFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point DCT4/IDCT4 function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_dct4_instance_f32 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: float32_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *mut float32_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *mut float32_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_f32,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_dct4_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Nby2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).normalize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCosFactor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pRfft) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCfft) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point DCT4/IDCT4.\n @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.\n @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.\n @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.\n @param[in]     N          length of the DCT4.\n @param[in]     Nby2       half of the length of the DCT4.\n @param[in]     normalize  normalizing factor.\n @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length."]
    pub fn arm_dct4_init_f32(
        S: *mut arm_dct4_instance_f32,
        S_RFFT: *mut arm_rfft_instance_f32,
        S_CFFT: *mut arm_cfft_radix4_instance_f32,
        N: u16,
        Nby2: u16,
        normalize: float32_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point DCT4/IDCT4.\n @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure.\n @param[in]     pState         points to state buffer.\n @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_f32(
        S: *const arm_dct4_instance_f32,
        pState: *mut float32_t,
        pInlineBuffer: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the Q31 DCT4/IDCT4 function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_dct4_instance_q31 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: q31_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *mut q31_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *mut q31_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_q31,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_dct4_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Nby2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).normalize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCosFactor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pRfft) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCfft) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 DCT4/IDCT4.\n @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.\n @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure\n @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure\n @param[in]     N          length of the DCT4.\n @param[in]     Nby2       half of the length of the DCT4.\n @param[in]     normalize  normalizing factor.\n @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length."]
    pub fn arm_dct4_init_q31(
        S: *mut arm_dct4_instance_q31,
        S_RFFT: *mut arm_rfft_instance_q31,
        S_CFFT: *mut arm_cfft_radix4_instance_q31,
        N: u16,
        Nby2: u16,
        normalize: q31_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 DCT4/IDCT4.\n @param[in]     S              points to an instance of the Q31 DCT4 structure.\n @param[in]     pState         points to state buffer.\n @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_q31(
        S: *const arm_dct4_instance_q31,
        pState: *mut q31_t,
        pInlineBuffer: *mut q31_t,
    );
}
#[doc = " @brief Instance structure for the Q15 DCT4/IDCT4 function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_dct4_instance_q15 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: q15_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *mut q15_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *mut q15_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_q15,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_dct4_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Nby2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).normalize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTwiddle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCosFactor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pRfft) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCfft) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 DCT4/IDCT4.\n @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.\n @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.\n @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.\n @param[in]     N          length of the DCT4.\n @param[in]     Nby2       half of the length of the DCT4.\n @param[in]     normalize  normalizing factor.\n @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length."]
    pub fn arm_dct4_init_q15(
        S: *mut arm_dct4_instance_q15,
        S_RFFT: *mut arm_rfft_instance_q15,
        S_CFFT: *mut arm_cfft_radix4_instance_q15,
        N: u16,
        Nby2: u16,
        normalize: q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 DCT4/IDCT4.\n @param[in]     S              points to an instance of the Q15 DCT4 structure.\n @param[in]     pState         points to state buffer.\n @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_q15(
        S: *const arm_dct4_instance_q15,
        pState: *mut q15_t,
        pInlineBuffer: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Floating-point vector addition.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_f32(
        pSrcA: *mut float32_t,
        pSrcB: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector addition.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q7(pSrcA: *mut q7_t, pSrcB: *mut q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector addition.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q15(pSrcA: *mut q15_t, pSrcB: *mut q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector addition.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q31(pSrcA: *mut q31_t, pSrcB: *mut q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector subtraction.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_f32(
        pSrcA: *mut float32_t,
        pSrcB: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector subtraction.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q7(pSrcA: *mut q7_t, pSrcB: *mut q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector subtraction.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q15(pSrcA: *mut q15_t, pSrcB: *mut q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector subtraction.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q31(pSrcA: *mut q31_t, pSrcB: *mut q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Multiplies a floating-point vector by a scalar.\n @param[in]  pSrc       points to the input vector\n @param[in]  scale      scale factor to be applied\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_scale_f32(
        pSrc: *mut float32_t,
        scale: float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q7 vector by a scalar.\n @param[in]  pSrc        points to the input vector\n @param[in]  scaleFract  fractional portion of the scale value\n @param[in]  shift       number of bits to shift the result by\n @param[out] pDst        points to the output vector\n @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q7(
        pSrc: *mut q7_t,
        scaleFract: q7_t,
        shift: i8,
        pDst: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q15 vector by a scalar.\n @param[in]  pSrc        points to the input vector\n @param[in]  scaleFract  fractional portion of the scale value\n @param[in]  shift       number of bits to shift the result by\n @param[out] pDst        points to the output vector\n @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q15(
        pSrc: *mut q15_t,
        scaleFract: q15_t,
        shift: i8,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q31 vector by a scalar.\n @param[in]  pSrc        points to the input vector\n @param[in]  scaleFract  fractional portion of the scale value\n @param[in]  shift       number of bits to shift the result by\n @param[out] pDst        points to the output vector\n @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q31(
        pSrc: *mut q31_t,
        scaleFract: q31_t,
        shift: i8,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector absolute value.\n @param[in]  pSrc       points to the input buffer\n @param[out] pDst       points to the output buffer\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q7(pSrc: *mut q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector absolute value.\n @param[in]  pSrc       points to the input buffer\n @param[out] pDst       points to the output buffer\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_f32(pSrc: *mut float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector absolute value.\n @param[in]  pSrc       points to the input buffer\n @param[out] pDst       points to the output buffer\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q15(pSrc: *mut q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector absolute value.\n @param[in]  pSrc       points to the input buffer\n @param[out] pDst       points to the output buffer\n @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q31(pSrc: *mut q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Dot product of floating-point vectors.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[in]  blockSize  number of samples in each vector\n @param[out] result     output result returned here"]
    pub fn arm_dot_prod_f32(
        pSrcA: *mut float32_t,
        pSrcB: *mut float32_t,
        blockSize: u32,
        result: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q7 vectors.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[in]  blockSize  number of samples in each vector\n @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q7(pSrcA: *mut q7_t, pSrcB: *mut q7_t, blockSize: u32, result: *mut q31_t);
}
extern "C" {
    #[doc = " @brief Dot product of Q15 vectors.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[in]  blockSize  number of samples in each vector\n @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q15(
        pSrcA: *mut q15_t,
        pSrcB: *mut q15_t,
        blockSize: u32,
        result: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q31 vectors.\n @param[in]  pSrcA      points to the first input vector\n @param[in]  pSrcB      points to the second input vector\n @param[in]  blockSize  number of samples in each vector\n @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q31(
        pSrcA: *mut q31_t,
        pSrcB: *mut q31_t,
        blockSize: u32,
        result: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q7 vector a specified number of bits.\n @param[in]  pSrc       points to the input vector\n @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q7(pSrc: *mut q7_t, shiftBits: i8, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q15 vector a specified number of bits.\n @param[in]  pSrc       points to the input vector\n @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q15(pSrc: *mut q15_t, shiftBits: i8, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q31 vector a specified number of bits.\n @param[in]  pSrc       points to the input vector\n @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right.\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q31(pSrc: *mut q31_t, shiftBits: i8, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a floating-point vector.\n @param[in]  pSrc       points to the input vector\n @param[in]  offset     is the offset to be added\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_f32(
        pSrc: *mut float32_t,
        offset: float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q7 vector.\n @param[in]  pSrc       points to the input vector\n @param[in]  offset     is the offset to be added\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q7(pSrc: *mut q7_t, offset: q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q15 vector.\n @param[in]  pSrc       points to the input vector\n @param[in]  offset     is the offset to be added\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q15(pSrc: *mut q15_t, offset: q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q31 vector.\n @param[in]  pSrc       points to the input vector\n @param[in]  offset     is the offset to be added\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q31(pSrc: *mut q31_t, offset: q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a floating-point vector.\n @param[in]  pSrc       points to the input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_f32(pSrc: *mut float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q7 vector.\n @param[in]  pSrc       points to the input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q7(pSrc: *mut q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q15 vector.\n @param[in]  pSrc       points to the input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q15(pSrc: *mut q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q31 vector.\n @param[in]  pSrc       points to the input vector\n @param[out] pDst       points to the output vector\n @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q31(pSrc: *mut q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a floating-point vector.\n @param[in]  pSrc       input pointer\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_f32(pSrc: *mut float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q7 vector.\n @param[in]  pSrc       input pointer\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q7(pSrc: *mut q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q15 vector.\n @param[in]  pSrc       input pointer\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q15(pSrc: *mut q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q31 vector.\n @param[in]  pSrc       input pointer\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q31(pSrc: *mut q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a floating-point vector.\n @param[in]  value      input value to be filled\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_f32(value: float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q7 vector.\n @param[in]  value      input value to be filled\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q7(value: q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q15 vector.\n @param[in]  value      input value to be filled\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q15(value: q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q31 vector.\n @param[in]  value      input value to be filled\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q31(value: q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Convolution of floating-point sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1."]
    pub fn arm_conv_f32(
        pSrcA: *mut float32_t,
        srcALen: u32,
        pSrcB: *mut float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences.\n @param[in]  pSrcA      points to the first input sequence.\n @param[in]  srcALen    length of the first input sequence.\n @param[in]  pSrcB      points to the second input sequence.\n @param[in]  srcBLen    length of the second input sequence.\n @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.\n @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen)."]
    pub fn arm_conv_opt_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_fast_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA      points to the first input sequence.\n @param[in]  srcALen    length of the first input sequence.\n @param[in]  pSrcB      points to the second input sequence.\n @param[in]  srcBLen    length of the second input sequence.\n @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.\n @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen)."]
    pub fn arm_conv_fast_opt_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q31 sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q31(
        pSrcA: *mut q31_t,
        srcALen: u32,
        pSrcB: *mut q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_fast_q31(
        pSrcA: *mut q31_t,
        srcALen: u32,
        pSrcB: *mut q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q7 sequences.\n @param[in]  pSrcA      points to the first input sequence.\n @param[in]  srcALen    length of the first input sequence.\n @param[in]  pSrcB      points to the second input sequence.\n @param[in]  srcBLen    length of the second input sequence.\n @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.\n @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    pub fn arm_conv_opt_q7(
        pSrcA: *mut q7_t,
        srcALen: u32,
        pSrcB: *mut q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q7 sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q7(
        pSrcA: *mut q7_t,
        srcALen: u32,
        pSrcB: *mut q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
    );
}
extern "C" {
    #[doc = " @brief Partial convolution of floating-point sequences.\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_f32(
        pSrcA: *mut float32_t,
        srcALen: u32,
        pSrcB: *mut float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences.\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_opt_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences.\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_opt_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q31 sequences.\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q31(
        pSrcA: *mut q31_t,
        srcALen: u32,
        pSrcB: *mut q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_q31(
        pSrcA: *mut q31_t,
        srcALen: u32,
        pSrcB: *mut q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q7 sequences\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_opt_q7(
        pSrcA: *mut q7_t,
        srcALen: u32,
        pSrcB: *mut q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q7 sequences.\n @param[in]  pSrcA       points to the first input sequence.\n @param[in]  srcALen     length of the first input sequence.\n @param[in]  pSrcB       points to the second input sequence.\n @param[in]  srcBLen     length of the second input sequence.\n @param[out] pDst        points to the block of output data\n @param[in]  firstIndex  is the first output sample to start with.\n @param[in]  numPoints   is the number of output points to be computed.\n @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q7(
        pSrcA: *mut q7_t,
        srcALen: u32,
        pSrcB: *mut q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status;
}
#[doc = " @brief Instance structure for the Q15 FIR decimator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_decimate_instance_q15 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_decimate_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_q15>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).M) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR decimator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_decimate_instance_q31 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_decimate_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_q31>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).M) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR decimator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_decimate_instance_f32 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_decimate_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_f32>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).M) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(pState)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR decimator.\n @param[in]  S          points to an instance of the floating-point FIR decimator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_f32(
        S: *const arm_fir_decimate_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR decimator.\n @param[in,out] S          points to an instance of the floating-point FIR decimator structure.\n @param[in]     numTaps    number of coefficients in the filter.\n @param[in]     M          decimation factor.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of input samples to process per call.\n @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if\n <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_f32(
        S: *mut arm_fir_decimate_instance_f32,
        numTaps: u16,
        M: u8,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR decimator.\n @param[in]  S          points to an instance of the Q15 FIR decimator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_q15(
        S: *const arm_fir_decimate_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.\n @param[in]  S          points to an instance of the Q15 FIR decimator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_fast_q15(
        S: *const arm_fir_decimate_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR decimator.\n @param[in,out] S          points to an instance of the Q15 FIR decimator structure.\n @param[in]     numTaps    number of coefficients in the filter.\n @param[in]     M          decimation factor.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of input samples to process per call.\n @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if\n <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_q15(
        S: *mut arm_fir_decimate_instance_q15,
        numTaps: u16,
        M: u8,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR decimator.\n @param[in]  S     points to an instance of the Q31 FIR decimator structure.\n @param[in]  pSrc  points to the block of input data.\n @param[out] pDst  points to the block of output data\n @param[in] blockSize number of input samples to process per call."]
    pub fn arm_fir_decimate_q31(
        S: *const arm_fir_decimate_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.\n @param[in]  S          points to an instance of the Q31 FIR decimator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_fast_q31(
        S: *mut arm_fir_decimate_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR decimator.\n @param[in,out] S          points to an instance of the Q31 FIR decimator structure.\n @param[in]     numTaps    number of coefficients in the filter.\n @param[in]     M          decimation factor.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of input samples to process per call.\n @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if\n <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_q31(
        S: *mut arm_fir_decimate_instance_q31,
        numTaps: u16,
        M: u8,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    ) -> arm_status;
}
#[doc = " @brief Instance structure for the Q15 FIR interpolator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_interpolate_instance_q15 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< points to the state variable array. The array is of length blockSize+phaseLength-1."]
    pub pState: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_interpolate_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_q15>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_q15>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_q15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).L) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phaseLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR interpolator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_interpolate_instance_q31 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< points to the state variable array. The array is of length blockSize+phaseLength-1."]
    pub pState: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_interpolate_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_q31>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_q31>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_q31)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).L) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phaseLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR interpolator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_interpolate_instance_f32 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< points to the state variable array. The array is of length phaseLength+numTaps-1."]
    pub pState: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_interpolate_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_f32>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_f32>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_f32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).L) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phaseLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(pState)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR interpolator.\n @param[in]  S          points to an instance of the Q15 FIR interpolator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_q15(
        S: *const arm_fir_interpolate_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR interpolator.\n @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.\n @param[in]     L          upsample factor.\n @param[in]     numTaps    number of filter coefficients in the filter.\n @param[in]     pCoeffs    points to the filter coefficient buffer.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of input samples to process per call.\n @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if\n the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_q15(
        S: *mut arm_fir_interpolate_instance_q15,
        L: u8,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR interpolator.\n @param[in]  S          points to an instance of the Q15 FIR interpolator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_q31(
        S: *const arm_fir_interpolate_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR interpolator.\n @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.\n @param[in]     L          upsample factor.\n @param[in]     numTaps    number of filter coefficients in the filter.\n @param[in]     pCoeffs    points to the filter coefficient buffer.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of input samples to process per call.\n @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if\n the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_q31(
        S: *mut arm_fir_interpolate_instance_q31,
        L: u8,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR interpolator.\n @param[in]  S          points to an instance of the floating-point FIR interpolator structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_f32(
        S: *const arm_fir_interpolate_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR interpolator.\n @param[in,out] S          points to an instance of the floating-point FIR interpolator structure.\n @param[in]     L          upsample factor.\n @param[in]     numTaps    number of filter coefficients in the filter.\n @param[in]     pCoeffs    points to the filter coefficient buffer.\n @param[in]     pState     points to the state buffer.\n @param[in]     blockSize  number of input samples to process per call.\n @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if\n the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_f32(
        S: *mut arm_fir_interpolate_instance_f32,
        L: u8,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    ) -> arm_status;
}
#[doc = " @brief Instance structure for the high precision Q31 Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_cas_df1_32x64_ins_q31 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q63_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< additional shift, in bits, applied to each output sample."]
    pub postShift: u8,
}
#[test]
fn bindgen_test_layout_arm_biquad_cas_df1_32x64_ins_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_cas_df1_32x64_ins_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cas_df1_32x64_ins_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_biquad_cas_df1_32x64_ins_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cas_df1_32x64_ins_q31>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cas_df1_32x64_q31(
        S: *const arm_biquad_cas_df1_32x64_ins_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filter structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     postShift  shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cas_df1_32x64_init_q31(
        S: *mut arm_biquad_cas_df1_32x64_ins_q31,
        numStages: u8,
        pCoeffs: *mut q31_t,
        pState: *mut q63_t,
        postShift: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_cascade_df2T_instance_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 2*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_df2T_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_cascade_df2T_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_df2T_instance_f32>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_df2T_instance_f32>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_df2T_instance_f32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_cascade_stereo_df2T_instance_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_stereo_df2T_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_cascade_stereo_df2T_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_stereo_df2T_instance_f32>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_stereo_df2T_instance_f32>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_biquad_cascade_df2T_instance_f64 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 2*numStages."]
    pub pState: *mut float64_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut float64_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_df2T_instance_f64() {
    const UNINIT: ::core::mem::MaybeUninit<arm_biquad_cascade_df2T_instance_f64> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_df2T_instance_f64>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_df2T_instance_f64>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_df2T_instance_f64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.\n @param[in]  S          points to an instance of the filter data structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df2T_f32(
        S: *const arm_biquad_cascade_df2T_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels\n @param[in]  S          points to an instance of the filter data structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_stereo_df2T_f32(
        S: *const arm_biquad_cascade_stereo_df2T_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.\n @param[in]  S          points to an instance of the filter data structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df2T_f64(
        S: *const arm_biquad_cascade_df2T_instance_f64,
        pSrc: *mut float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.\n @param[in,out] S          points to an instance of the filter data structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df2T_init_f32(
        S: *mut arm_biquad_cascade_df2T_instance_f32,
        numStages: u8,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.\n @param[in,out] S          points to an instance of the filter data structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_stereo_df2T_init_f32(
        S: *mut arm_biquad_cascade_stereo_df2T_instance_f32,
        numStages: u8,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.\n @param[in,out] S          points to an instance of the filter data structure.\n @param[in]     numStages  number of 2nd order stages in the filter.\n @param[in]     pCoeffs    points to the filter coefficients.\n @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df2T_init_f64(
        S: *mut arm_biquad_cascade_df2T_instance_f64,
        numStages: u8,
        pCoeffs: *mut float64_t,
        pState: *mut float64_t,
    );
}
#[doc = " @brief Instance structure for the Q15 FIR lattice filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_lattice_instance_q15 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_lattice_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_q15>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR lattice filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_lattice_instance_q31 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_lattice_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_q31>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR lattice filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_lattice_instance_f32 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_lattice_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_f32>(),
        12usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 FIR lattice filter.\n @param[in] S          points to an instance of the Q15 FIR lattice structure.\n @param[in] numStages  number of filter stages.\n @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.\n @param[in] pState     points to the state buffer.  The array is of length numStages."]
    pub fn arm_fir_lattice_init_q15(
        S: *mut arm_fir_lattice_instance_q15,
        numStages: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR lattice filter.\n @param[in]  S          points to an instance of the Q15 FIR lattice structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_q15(
        S: *const arm_fir_lattice_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q31 FIR lattice filter.\n @param[in] S          points to an instance of the Q31 FIR lattice structure.\n @param[in] numStages  number of filter stages.\n @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.\n @param[in] pState     points to the state buffer.   The array is of length numStages."]
    pub fn arm_fir_lattice_init_q31(
        S: *mut arm_fir_lattice_instance_q31,
        numStages: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR lattice filter.\n @param[in]  S          points to an instance of the Q31 FIR lattice structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_q31(
        S: *const arm_fir_lattice_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point FIR lattice filter.\n @param[in] S          points to an instance of the floating-point FIR lattice structure.\n @param[in] numStages  number of filter stages.\n @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.\n @param[in] pState     points to the state buffer.  The array is of length numStages."]
    pub fn arm_fir_lattice_init_f32(
        S: *mut arm_fir_lattice_instance_f32,
        numStages: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR lattice filter.\n @param[in]  S          points to an instance of the floating-point FIR lattice structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_f32(
        S: *const arm_fir_lattice_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 IIR lattice filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_iir_lattice_instance_q15 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut q15_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut q15_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_iir_lattice_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvCoeffs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 IIR lattice filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_iir_lattice_instance_q31 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut q31_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut q31_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_iir_lattice_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvCoeffs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point IIR lattice filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_iir_lattice_instance_f32 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut float32_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut float32_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_iir_lattice_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numStages) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvCoeffs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point IIR lattice filter.\n @param[in]  S          points to an instance of the floating-point IIR lattice structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_f32(
        S: *const arm_iir_lattice_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point IIR lattice filter.\n @param[in] S          points to an instance of the floating-point IIR lattice structure.\n @param[in] numStages  number of stages in the filter.\n @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages.\n @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1.\n @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-1.\n @param[in] blockSize  number of samples to process."]
    pub fn arm_iir_lattice_init_f32(
        S: *mut arm_iir_lattice_instance_f32,
        numStages: u16,
        pkCoeffs: *mut float32_t,
        pvCoeffs: *mut float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 IIR lattice filter.\n @param[in]  S          points to an instance of the Q31 IIR lattice structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_q31(
        S: *const arm_iir_lattice_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q31 IIR lattice filter.\n @param[in] S          points to an instance of the Q31 IIR lattice structure.\n @param[in] numStages  number of stages in the filter.\n @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages.\n @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1.\n @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.\n @param[in] blockSize  number of samples to process."]
    pub fn arm_iir_lattice_init_q31(
        S: *mut arm_iir_lattice_instance_q31,
        numStages: u16,
        pkCoeffs: *mut q31_t,
        pvCoeffs: *mut q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 IIR lattice filter.\n @param[in]  S          points to an instance of the Q15 IIR lattice structure.\n @param[in]  pSrc       points to the block of input data.\n @param[out] pDst       points to the block of output data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_q15(
        S: *const arm_iir_lattice_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 IIR lattice filter.\n @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.\n @param[in] numStages  number of stages in the filter.\n @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages.\n @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.\n @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.\n @param[in] blockSize  number of samples to process per call."]
    pub fn arm_iir_lattice_init_q15(
        S: *mut arm_iir_lattice_instance_q15,
        numStages: u16,
        pkCoeffs: *mut q15_t,
        pvCoeffs: *mut q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the floating-point LMS filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_lms_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: float32_t,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_lms_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_lms_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(mu)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for floating-point LMS filter.\n @param[in]  S          points to an instance of the floating-point LMS filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[in]  pRef       points to the block of reference data.\n @param[out] pOut       points to the block of output data.\n @param[out] pErr       points to the block of error data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_f32(
        S: *const arm_lms_instance_f32,
        pSrc: *mut float32_t,
        pRef: *mut float32_t,
        pOut: *mut float32_t,
        pErr: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for floating-point LMS filter.\n @param[in] S          points to an instance of the floating-point LMS filter structure.\n @param[in] numTaps    number of filter coefficients.\n @param[in] pCoeffs    points to the coefficient buffer.\n @param[in] pState     points to state buffer.\n @param[in] mu         step size that controls filter coefficient updates.\n @param[in] blockSize  number of samples to process."]
    pub fn arm_lms_init_f32(
        S: *mut arm_lms_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        mu: float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 LMS filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_lms_instance_q15 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q15_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u32,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_lms_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_q15>(),
        20usize,
        concat!("Size of: ", stringify!(arm_lms_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 LMS filter.\n @param[in] S          points to an instance of the Q15 LMS filter structure.\n @param[in] numTaps    number of filter coefficients.\n @param[in] pCoeffs    points to the coefficient buffer.\n @param[in] pState     points to the state buffer.\n @param[in] mu         step size that controls filter coefficient updates.\n @param[in] blockSize  number of samples to process.\n @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_init_q15(
        S: *mut arm_lms_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        mu: q15_t,
        blockSize: u32,
        postShift: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q15 LMS filter.\n @param[in]  S          points to an instance of the Q15 LMS filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[in]  pRef       points to the block of reference data.\n @param[out] pOut       points to the block of output data.\n @param[out] pErr       points to the block of error data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_q15(
        S: *const arm_lms_instance_q15,
        pSrc: *mut q15_t,
        pRef: *mut q15_t,
        pOut: *mut q15_t,
        pErr: *mut q15_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q31 LMS filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_lms_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q31_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u32,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_lms_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_q31>(),
        20usize,
        concat!("Size of: ", stringify!(arm_lms_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q31 LMS filter.\n @param[in]  S          points to an instance of the Q15 LMS filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[in]  pRef       points to the block of reference data.\n @param[out] pOut       points to the block of output data.\n @param[out] pErr       points to the block of error data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_q31(
        S: *const arm_lms_instance_q31,
        pSrc: *mut q31_t,
        pRef: *mut q31_t,
        pOut: *mut q31_t,
        pErr: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q31 LMS filter.\n @param[in] S          points to an instance of the Q31 LMS filter structure.\n @param[in] numTaps    number of filter coefficients.\n @param[in] pCoeffs    points to coefficient buffer.\n @param[in] pState     points to state buffer.\n @param[in] mu         step size that controls filter coefficient updates.\n @param[in] blockSize  number of samples to process.\n @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_init_q31(
        S: *mut arm_lms_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        mu: q31_t,
        blockSize: u32,
        postShift: u32,
    );
}
#[doc = " @brief Instance structure for the floating-point normalized LMS filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_lms_norm_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< step size that control filter coefficient updates."]
    pub mu: float32_t,
    #[doc = "< saves previous frame energy."]
    pub energy: float32_t,
    #[doc = "< saves previous input sample."]
    pub x0: float32_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_lms_norm_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for floating-point normalized LMS filter.\n @param[in]  S          points to an instance of the floating-point normalized LMS filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[in]  pRef       points to the block of reference data.\n @param[out] pOut       points to the block of output data.\n @param[out] pErr       points to the block of error data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_f32(
        S: *mut arm_lms_norm_instance_f32,
        pSrc: *mut float32_t,
        pRef: *mut float32_t,
        pOut: *mut float32_t,
        pErr: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for floating-point normalized LMS filter.\n @param[in] S          points to an instance of the floating-point LMS filter structure.\n @param[in] numTaps    number of filter coefficients.\n @param[in] pCoeffs    points to coefficient buffer.\n @param[in] pState     points to state buffer.\n @param[in] mu         step size that controls filter coefficient updates.\n @param[in] blockSize  number of samples to process."]
    pub fn arm_lms_norm_init_f32(
        S: *mut arm_lms_norm_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        mu: float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q31 normalized LMS filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_lms_norm_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q31_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u8,
    #[doc = "< points to the reciprocal initial value table."]
    pub recipTable: *mut q31_t,
    #[doc = "< saves previous frame energy."]
    pub energy: q31_t,
    #[doc = "< saves previous input sample."]
    pub x0: q31_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_lms_norm_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(postShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recipTable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(recipTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x0) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q31 normalized LMS filter.\n @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[in]  pRef       points to the block of reference data.\n @param[out] pOut       points to the block of output data.\n @param[out] pErr       points to the block of error data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_q31(
        S: *mut arm_lms_norm_instance_q31,
        pSrc: *mut q31_t,
        pRef: *mut q31_t,
        pOut: *mut q31_t,
        pErr: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q31 normalized LMS filter.\n @param[in] S          points to an instance of the Q31 normalized LMS filter structure.\n @param[in] numTaps    number of filter coefficients.\n @param[in] pCoeffs    points to coefficient buffer.\n @param[in] pState     points to state buffer.\n @param[in] mu         step size that controls filter coefficient updates.\n @param[in] blockSize  number of samples to process.\n @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_norm_init_q31(
        S: *mut arm_lms_norm_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        mu: q31_t,
        blockSize: u32,
        postShift: u8,
    );
}
#[doc = " @brief Instance structure for the Q15 normalized LMS filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_lms_norm_instance_q15 {
    #[doc = "< Number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q15_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u8,
    #[doc = "< Points to the reciprocal initial value table."]
    pub recipTable: *mut q15_t,
    #[doc = "< saves previous frame energy."]
    pub energy: q15_t,
    #[doc = "< saves previous input sample."]
    pub x0: q15_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_lms_norm_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postShift) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(postShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recipTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(recipTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x0) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q15 normalized LMS filter.\n @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.\n @param[in]  pSrc       points to the block of input data.\n @param[in]  pRef       points to the block of reference data.\n @param[out] pOut       points to the block of output data.\n @param[out] pErr       points to the block of error data.\n @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_q15(
        S: *mut arm_lms_norm_instance_q15,
        pSrc: *mut q15_t,
        pRef: *mut q15_t,
        pOut: *mut q15_t,
        pErr: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q15 normalized LMS filter.\n @param[in] S          points to an instance of the Q15 normalized LMS filter structure.\n @param[in] numTaps    number of filter coefficients.\n @param[in] pCoeffs    points to coefficient buffer.\n @param[in] pState     points to state buffer.\n @param[in] mu         step size that controls filter coefficient updates.\n @param[in] blockSize  number of samples to process.\n @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_norm_init_q15(
        S: *mut arm_lms_norm_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        mu: q15_t,
        blockSize: u32,
        postShift: u8,
    );
}
extern "C" {
    #[doc = " @brief Correlation of floating-point sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_f32(
        pSrcA: *mut float32_t,
        srcALen: u32,
        pSrcB: *mut float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q15 sequences\n @param[in]  pSrcA     points to the first input sequence.\n @param[in]  srcALen   length of the first input sequence.\n @param[in]  pSrcB     points to the second input sequence.\n @param[in]  srcBLen   length of the second input sequence.\n @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.\n @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    pub fn arm_correlate_opt_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q15 sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_fast_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.\n @param[in]  pSrcA     points to the first input sequence.\n @param[in]  srcALen   length of the first input sequence.\n @param[in]  pSrcB     points to the second input sequence.\n @param[in]  srcBLen   length of the second input sequence.\n @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.\n @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    pub fn arm_correlate_fast_opt_q15(
        pSrcA: *mut q15_t,
        srcALen: u32,
        pSrcB: *mut q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q31 sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q31(
        pSrcA: *mut q31_t,
        srcALen: u32,
        pSrcB: *mut q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_fast_q31(
        pSrcA: *mut q31_t,
        srcALen: u32,
        pSrcB: *mut q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q7 sequences.\n @param[in]  pSrcA      points to the first input sequence.\n @param[in]  srcALen    length of the first input sequence.\n @param[in]  pSrcB      points to the second input sequence.\n @param[in]  srcBLen    length of the second input sequence.\n @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.\n @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.\n @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    pub fn arm_correlate_opt_q7(
        pSrcA: *mut q7_t,
        srcALen: u32,
        pSrcB: *mut q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q7 sequences.\n @param[in]  pSrcA    points to the first input sequence.\n @param[in]  srcALen  length of the first input sequence.\n @param[in]  pSrcB    points to the second input sequence.\n @param[in]  srcBLen  length of the second input sequence.\n @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q7(
        pSrcA: *mut q7_t,
        srcALen: u32,
        pSrcB: *mut q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
    );
}
#[doc = " @brief Instance structure for the floating-point sparse FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_sparse_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_f32() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_sparse_instance_f32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_f32>(),
        20usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_f32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stateIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxDelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTapDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 sparse FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_sparse_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q31() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_sparse_instance_q31> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q31>(),
        20usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q31))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stateIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxDelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTapDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 sparse FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_sparse_instance_q15 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q15() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_sparse_instance_q15> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q15>(),
        20usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q15>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q15))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stateIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxDelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTapDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q7 sparse FIR filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_fir_sparse_instance_q7 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q7_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q7_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q7() {
    const UNINIT: ::core::mem::MaybeUninit<arm_fir_sparse_instance_q7> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q7>(),
        20usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q7>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q7))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stateIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCoeffs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxDelay) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pTapDelay) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pTapDelay)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point sparse FIR filter.\n @param[in]  S           points to an instance of the floating-point sparse FIR structure.\n @param[in]  pSrc        points to the block of input data.\n @param[out] pDst        points to the block of output data\n @param[in]  pScratchIn  points to a temporary buffer of size blockSize.\n @param[in]  blockSize   number of input samples to process per call."]
    pub fn arm_fir_sparse_f32(
        S: *mut arm_fir_sparse_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        pScratchIn: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point sparse FIR filter.\n @param[in,out] S          points to an instance of the floating-point sparse FIR structure.\n @param[in]     numTaps    number of nonzero coefficients in the filter.\n @param[in]     pCoeffs    points to the array of filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     pTapDelay  points to the array of offset times.\n @param[in]     maxDelay   maximum offset time supported.\n @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_f32(
        S: *mut arm_fir_sparse_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 sparse FIR filter.\n @param[in]  S           points to an instance of the Q31 sparse FIR structure.\n @param[in]  pSrc        points to the block of input data.\n @param[out] pDst        points to the block of output data\n @param[in]  pScratchIn  points to a temporary buffer of size blockSize.\n @param[in]  blockSize   number of input samples to process per call."]
    pub fn arm_fir_sparse_q31(
        S: *mut arm_fir_sparse_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        pScratchIn: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 sparse FIR filter.\n @param[in,out] S          points to an instance of the Q31 sparse FIR structure.\n @param[in]     numTaps    number of nonzero coefficients in the filter.\n @param[in]     pCoeffs    points to the array of filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     pTapDelay  points to the array of offset times.\n @param[in]     maxDelay   maximum offset time supported.\n @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q31(
        S: *mut arm_fir_sparse_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 sparse FIR filter.\n @param[in]  S            points to an instance of the Q15 sparse FIR structure.\n @param[in]  pSrc         points to the block of input data.\n @param[out] pDst         points to the block of output data\n @param[in]  pScratchIn   points to a temporary buffer of size blockSize.\n @param[in]  pScratchOut  points to a temporary buffer of size blockSize.\n @param[in]  blockSize    number of input samples to process per call."]
    pub fn arm_fir_sparse_q15(
        S: *mut arm_fir_sparse_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        pScratchIn: *mut q15_t,
        pScratchOut: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 sparse FIR filter.\n @param[in,out] S          points to an instance of the Q15 sparse FIR structure.\n @param[in]     numTaps    number of nonzero coefficients in the filter.\n @param[in]     pCoeffs    points to the array of filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     pTapDelay  points to the array of offset times.\n @param[in]     maxDelay   maximum offset time supported.\n @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q15(
        S: *mut arm_fir_sparse_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q7 sparse FIR filter.\n @param[in]  S            points to an instance of the Q7 sparse FIR structure.\n @param[in]  pSrc         points to the block of input data.\n @param[out] pDst         points to the block of output data\n @param[in]  pScratchIn   points to a temporary buffer of size blockSize.\n @param[in]  pScratchOut  points to a temporary buffer of size blockSize.\n @param[in]  blockSize    number of input samples to process per call."]
    pub fn arm_fir_sparse_q7(
        S: *mut arm_fir_sparse_instance_q7,
        pSrc: *mut q7_t,
        pDst: *mut q7_t,
        pScratchIn: *mut q7_t,
        pScratchOut: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q7 sparse FIR filter.\n @param[in,out] S          points to an instance of the Q7 sparse FIR structure.\n @param[in]     numTaps    number of nonzero coefficients in the filter.\n @param[in]     pCoeffs    points to the array of filter coefficients.\n @param[in]     pState     points to the state buffer.\n @param[in]     pTapDelay  points to the array of offset times.\n @param[in]     maxDelay   maximum offset time supported.\n @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q7(
        S: *mut arm_fir_sparse_instance_q7,
        numTaps: u16,
        pCoeffs: *mut q7_t,
        pState: *mut q7_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point sin_cos function.\n @param[in]  theta   input value in degrees\n @param[out] pSinVal  points to the processed sine output.\n @param[out] pCosVal  points to the processed cos output."]
    pub fn arm_sin_cos_f32(theta: float32_t, pSinVal: *mut float32_t, pCosVal: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Q31 sin_cos function.\n @param[in]  theta    scaled input value in degrees\n @param[out] pSinVal  points to the processed sine output.\n @param[out] pCosVal  points to the processed cosine output."]
    pub fn arm_sin_cos_q31(theta: q31_t, pSinVal: *mut q31_t, pCosVal: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Floating-point complex conjugate.\n @param[in]  pSrc        points to the input vector\n @param[out] pDst        points to the output vector\n @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_f32(pSrc: *mut float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex conjugate.\n @param[in]  pSrc        points to the input vector\n @param[out] pDst        points to the output vector\n @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_q31(pSrc: *mut q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex conjugate.\n @param[in]  pSrc        points to the input vector\n @param[out] pDst        points to the output vector\n @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_q15(pSrc: *mut q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude squared\n @param[in]  pSrc        points to the complex input vector\n @param[out] pDst        points to the real output vector\n @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_f32(pSrc: *mut float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex magnitude squared\n @param[in]  pSrc        points to the complex input vector\n @param[out] pDst        points to the real output vector\n @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_q31(pSrc: *mut q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude squared\n @param[in]  pSrc        points to the complex input vector\n @param[out] pDst        points to the real output vector\n @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_q15(pSrc: *mut q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief Floating-point matrix inverse.\n @param[in]  src   points to the instance of the input floating-point matrix structure.\n @param[out] dst   points to the instance of the output floating-point matrix structure.\n @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.\n If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR."]
    pub fn arm_mat_inverse_f32(
        src: *const arm_matrix_instance_f32,
        dst: *mut arm_matrix_instance_f32,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief Floating-point matrix inverse.\n @param[in]  src   points to the instance of the input floating-point matrix structure.\n @param[out] dst   points to the instance of the output floating-point matrix structure.\n @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.\n If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR."]
    pub fn arm_mat_inverse_f64(
        src: *const arm_matrix_instance_f64,
        dst: *mut arm_matrix_instance_f64,
    ) -> arm_status;
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to Q31 vector.\n @param[in]  pSrc       input pointer\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_q7_to_q31(pSrc: *mut q7_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to Q15 vector.\n @param[in]  pSrc       input pointer\n @param[out] pDst       output pointer\n @param[in]  blockSize  number of samples to process"]
    pub fn arm_q7_to_q15(pSrc: *mut q7_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q7_to_float(pSrc: *mut q7_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_float(pSrc: *mut q31_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for floating-point data.\n @param[in] x  input value in radians.\n @return  sin(x)."]
    pub fn arm_sin_f32(x: float32_t) -> float32_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for Q31 data.\n @param[in] x  Scaled input value in radians.\n @return  sin(x)."]
    pub fn arm_sin_q31(x: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for Q15 data.\n @param[in] x  Scaled input value in radians.\n @return  sin(x)."]
    pub fn arm_sin_q15(x: q15_t) -> q15_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric cosine function for floating-point data.\n @param[in] x  input value in radians.\n @return  cos(x)."]
    pub fn arm_cos_f32(x: float32_t) -> float32_t;
}
extern "C" {
    #[doc = " @brief Fast approximation to the trigonometric cosine function for Q31 data.\n @param[in] x  Scaled input value in radians.\n @return  cos(x)."]
    pub fn arm_cos_q31(x: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric cosine function for Q15 data.\n @param[in] x  Scaled input value in radians.\n @return  cos(x)."]
    pub fn arm_cos_q15(x: q15_t) -> q15_t;
}
extern "C" {
    #[doc = " @brief Q31 square root function.\n @param[in]  in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF.\n @param[out] pOut  square root of input value.\n @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if\n <code>in</code> is negative value and returns zero output for negative values."]
    pub fn arm_sqrt_q31(in_: q31_t, pOut: *mut q31_t) -> arm_status;
}
extern "C" {
    #[doc = " @brief  Q15 square root function.\n @param[in]  in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.\n @param[out] pOut  square root of input value.\n @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if\n <code>in</code> is negative value and returns zero output for negative values."]
    pub fn arm_sqrt_q15(in_: q15_t, pOut: *mut q15_t) -> arm_status;
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_power_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q63_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_power_f32(pSrc: *mut float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_power_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q63_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q7 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_power_q7(pSrc: *mut q7_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q7 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_mean_q7(pSrc: *mut q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_mean_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_mean_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_mean_f32(pSrc: *mut float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_var_f32(pSrc: *mut float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_var_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_var_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_rms_f32(pSrc: *mut float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_rms_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_rms_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_std_f32(pSrc: *mut float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_std_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output value."]
    pub fn arm_std_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude\n @param[in]  pSrc        points to the complex input vector\n @param[out] pDst        points to the real output vector\n @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_f32(pSrc: *mut float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex magnitude\n @param[in]  pSrc        points to the complex input vector\n @param[out] pDst        points to the real output vector\n @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_q31(pSrc: *mut q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude\n @param[in]  pSrc        points to the complex input vector\n @param[out] pDst        points to the real output vector\n @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_q15(pSrc: *mut q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex dot product\n @param[in]  pSrcA       points to the first input vector\n @param[in]  pSrcB       points to the second input vector\n @param[in]  numSamples  number of complex samples in each vector\n @param[out] realResult  real part of the result returned here\n @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_q15(
        pSrcA: *mut q15_t,
        pSrcB: *mut q15_t,
        numSamples: u32,
        realResult: *mut q31_t,
        imagResult: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex dot product\n @param[in]  pSrcA       points to the first input vector\n @param[in]  pSrcB       points to the second input vector\n @param[in]  numSamples  number of complex samples in each vector\n @param[out] realResult  real part of the result returned here\n @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_q31(
        pSrcA: *mut q31_t,
        pSrcB: *mut q31_t,
        numSamples: u32,
        realResult: *mut q63_t,
        imagResult: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex dot product\n @param[in]  pSrcA       points to the first input vector\n @param[in]  pSrcB       points to the second input vector\n @param[in]  numSamples  number of complex samples in each vector\n @param[out] realResult  real part of the result returned here\n @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_f32(
        pSrcA: *mut float32_t,
        pSrcB: *mut float32_t,
        numSamples: u32,
        realResult: *mut float32_t,
        imagResult: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Q15 complex-by-real multiplication\n @param[in]  pSrcCmplx   points to the complex input vector\n @param[in]  pSrcReal    points to the real input vector\n @param[out] pCmplxDst   points to the complex output vector\n @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_q15(
        pSrcCmplx: *mut q15_t,
        pSrcReal: *mut q15_t,
        pCmplxDst: *mut q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex-by-real multiplication\n @param[in]  pSrcCmplx   points to the complex input vector\n @param[in]  pSrcReal    points to the real input vector\n @param[out] pCmplxDst   points to the complex output vector\n @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_q31(
        pSrcCmplx: *mut q31_t,
        pSrcReal: *mut q31_t,
        pCmplxDst: *mut q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-real multiplication\n @param[in]  pSrcCmplx   points to the complex input vector\n @param[in]  pSrcReal    points to the real input vector\n @param[out] pCmplxDst   points to the complex output vector\n @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_f32(
        pSrcCmplx: *mut float32_t,
        pSrcReal: *mut float32_t,
        pCmplxDst: *mut float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q7 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] result     is output pointer\n @param[in]  index      is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q7(pSrc: *mut q7_t, blockSize: u32, result: *mut q7_t, index: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output pointer\n @param[in]  pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q15_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output pointer\n @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q31_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of a floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[in]  blockSize  is the number of samples to process\n @param[out] pResult    is output pointer\n @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_f32(
        pSrc: *mut float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of a Q7 vector.\n @param[in]  pSrc       points to the input buffer\n @param[in]  blockSize  length of the input vector\n @param[out] pResult    maximum value returned here\n @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q7(pSrc: *mut q7_t, blockSize: u32, pResult: *mut q7_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q15 vector.\n @param[in]  pSrc       points to the input buffer\n @param[in]  blockSize  length of the input vector\n @param[out] pResult    maximum value returned here\n @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q15(pSrc: *mut q15_t, blockSize: u32, pResult: *mut q15_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q31 vector.\n @param[in]  pSrc       points to the input buffer\n @param[in]  blockSize  length of the input vector\n @param[out] pResult    maximum value returned here\n @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q31(pSrc: *mut q31_t, blockSize: u32, pResult: *mut q31_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of a floating-point vector.\n @param[in]  pSrc       points to the input buffer\n @param[in]  blockSize  length of the input vector\n @param[out] pResult    maximum value returned here\n @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_f32(
        pSrc: *mut float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Q15 complex-by-complex multiplication\n @param[in]  pSrcA       points to the first input vector\n @param[in]  pSrcB       points to the second input vector\n @param[out] pDst        points to the output vector\n @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_q15(
        pSrcA: *mut q15_t,
        pSrcB: *mut q15_t,
        pDst: *mut q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex-by-complex multiplication\n @param[in]  pSrcA       points to the first input vector\n @param[in]  pSrcB       points to the second input vector\n @param[out] pDst        points to the output vector\n @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_q31(
        pSrcA: *mut q31_t,
        pSrcB: *mut q31_t,
        pDst: *mut q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-complex multiplication\n @param[in]  pSrcA       points to the first input vector\n @param[in]  pSrcB       points to the second input vector\n @param[out] pDst        points to the output vector\n @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_f32(
        pSrcA: *mut float32_t,
        pSrcB: *mut float32_t,
        pDst: *mut float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q31 vector.\n @param[in]  pSrc       points to the floating-point input vector\n @param[out] pDst       points to the Q31 output vector\n @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q31(pSrc: *mut float32_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q15 vector.\n @param[in]  pSrc       points to the floating-point input vector\n @param[out] pDst       points to the Q15 output vector\n @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q15(pSrc: *mut float32_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q7 vector.\n @param[in]  pSrc       points to the floating-point input vector\n @param[out] pDst       points to the Q7 output vector\n @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q7(pSrc: *mut float32_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to Q15 vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_q15(pSrc: *mut q31_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to Q7 vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_q7(pSrc: *mut q31_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to floating-point vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_float(pSrc: *mut q15_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to Q31 vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_q31(pSrc: *mut q15_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to Q7 vector.\n @param[in]  pSrc       is input pointer\n @param[out] pDst       is output pointer\n @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_q7(pSrc: *mut q15_t, pDst: *mut q7_t, blockSize: u32);
}
pub type q7_0_t = i8;
pub type q8_t = u8;
pub type q8_0_t = u8;
pub type q1_14_t = i16;
pub type q2_13_t = i16;
pub type q3_12_t = i16;
pub type q4_11_t = i16;
pub type q5_10_t = i16;
pub type q6_9_t = i16;
pub type q7_8_t = i16;
pub type q8_7_t = i16;
pub type q13_2_t = i16;
pub type q15_0_t = i16;
pub type uq16_t = u16;
pub type uq16_0_t = u16;
pub type q23_t = i32;
pub type q1_30_t = i32;
pub type q2_29_t = i32;
pub type q3_28_t = i32;
pub type q4_27_t = i32;
pub type q5_26_t = i32;
pub type q6_25_t = i32;
pub type q7_24_t = i32;
pub type q8_23_t = i32;
pub type q15_16_t = i32;
pub type q16_15_t = i32;
pub type q17_14_t = i32;
pub type q18_13_t = i32;
pub type q19_12_t = i32;
pub type q20_11_t = i32;
pub type q21_10_t = i32;
pub type q22_9_t = i32;
pub type q23_8_t = i32;
pub type q31_0_t = i32;
pub type uq32_t = u32;
pub type uq14_18_t = u32;
pub type uq32_0_t = u32;
pub type q1_62_t = i64;
pub type q2_61_t = i64;
pub type q3_60_t = i64;
pub type q4_59_t = i64;
pub type q5_58_t = i64;
pub type q6_57_t = i64;
pub type q7_56_t = i64;
pub type q8_55_t = i64;
pub type q16_47_t = i64;
pub type q23_40_t = i64;
pub type q31_32_t = i64;
pub type q63_0_t = i64;
pub type uq64_t = u64;
pub type uq64_0_t = u64;
extern "C" {
    #[doc = " Maximum"]
    pub fn q15max(a: q15_t, b: q15_t) -> q15_t;
}
extern "C" {
    #[doc = " Minimum"]
    pub fn q15min(a: q15_t, b: q15_t) -> q15_t;
}
extern "C" {
    #[doc = " Maximum"]
    pub fn q15maxp(a: i32, b: i32) -> i32;
}
extern "C" {
    #[doc = " Minimum"]
    pub fn q15minp(a: i32, b: i32) -> i32;
}
extern "C" {
    #[doc = " Maximum"]
    pub fn q31max(a: q31_t, b: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " Minimum"]
    pub fn q31min(a: q31_t, b: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " Clip upper bound of signed integer x to m (inclusive)"]
    pub fn clipmaxi32(x: i32, m: i32) -> i32;
}
extern "C" {
    #[doc = " Clip lower bound of signed integer x to m (inclusive)"]
    pub fn clipmini32(m: i32, x: i32) -> i32;
}
extern "C" {
    #[doc = " Clip signe integer x between min and max (inclusive)"]
    pub fn clipminmaxi32(min: i32, x: i32, max: i32) -> i32;
}
extern "C" {
    #[doc = " Clip upper bound of unsigned integer x to m (inclusive)"]
    pub fn clipmaxu32(x: u32, m: u32) -> u32;
}
extern "C" {
    #[doc = " Clip lower bound of unsigned integer x to m (inclusive)"]
    pub fn clipminu32(m: u32, x: u32) -> u32;
}
extern "C" {
    #[doc = " Clip unsigned integer x between min and max (inclusive)"]
    pub fn clipminmaxu32(min: u32, x: u32, max: u32) -> u32;
}
extern "C" {
    #[doc = " Compute next power of 2 greater than x"]
    pub fn nextpow2_u32(x: u32) -> u32;
}
extern "C" {
    #[doc = " Check if x is a power of 2"]
    pub fn ispow2_u32(x: u32) -> u8;
}
#[doc = " @name    Types\n @{"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union f32_t {
    pub f: f32,
    pub i: u32,
}
#[test]
fn bindgen_test_layout_f32_t() {
    const UNINIT: ::core::mem::MaybeUninit<f32_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<f32_t>(),
        4usize,
        concat!("Size of: ", stringify!(f32_t))
    );
    assert_eq!(
        ::core::mem::align_of::<f32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(f32_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(f32_t), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(f32_t), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f32pair_t {
    pub a: f32,
    pub b: f32,
}
#[test]
fn bindgen_test_layout_f32pair_t() {
    const UNINIT: ::core::mem::MaybeUninit<f32pair_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<f32pair_t>(),
        8usize,
        concat!("Size of: ", stringify!(f32pair_t))
    );
    assert_eq!(
        ::core::mem::align_of::<f32pair_t>(),
        4usize,
        concat!("Alignment of ", stringify!(f32pair_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(f32pair_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(f32pair_t),
            "::",
            stringify!(b)
        )
    );
}
extern "C" {
    #[doc = " Make a float pair."]
    pub fn f32pair(a: f32, b: f32) -> f32pair_t;
}
extern "C" {
    #[doc = " FSEL construct"]
    pub fn fsel(a: f32, b: f32, c: f32) -> f32;
}
extern "C" {
    #[doc = " FSEL boolean construct"]
    pub fn fselb(a: f32) -> u8;
}
extern "C" {
    #[doc = " Sign bit check."]
    pub fn float_is_neg(f: f32_t) -> u8;
}
extern "C" {
    #[doc = " Obtain mantissa"]
    pub fn float_mantissa(f: f32_t) -> i32;
}
extern "C" {
    #[doc = " Obtain exponent"]
    pub fn float_exponent(f: f32_t) -> i32;
}
extern "C" {
    #[doc = " Pair-wise addition"]
    pub fn f32pair_add(p0: f32pair_t, p1: f32pair_t) -> f32pair_t;
}
extern "C" {
    #[doc = " Pair-wise subtraction"]
    pub fn f32pair_sub(p0: f32pair_t, p1: f32pair_t) -> f32pair_t;
}
extern "C" {
    #[doc = " Pair-wise scalar addition"]
    pub fn f32pair_addscal(p: f32pair_t, scl: f32) -> f32pair_t;
}
extern "C" {
    #[doc = " Pair-wise product"]
    pub fn f32pair_mul(p0: f32pair_t, p1: f32pair_t) -> f32pair_t;
}
extern "C" {
    #[doc = " Pair-wise scalar product"]
    pub fn f32pair_mulscal(p: f32pair_t, scl: f32) -> f32pair_t;
}
extern "C" {
    #[doc = " Pair-wise linear interpolation"]
    pub fn f32pair_linint(fr: f32, p0: f32pair_t, p1: f32pair_t) -> f32pair_t;
}
extern "C" {
    #[doc = " Return x with sign of y applied"]
    pub fn si_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
    #[doc = " Absolute value"]
    pub fn si_fabsf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Floor function"]
    pub fn si_floorf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Ceiling function"]
    pub fn si_ceilf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Round to nearest integer."]
    pub fn si_roundf(x: f32) -> f32;
}
extern "C" {
    pub fn clampfsel(min: f32, x: f32, max: f32) -> f32;
}
extern "C" {
    pub fn clampminfsel(min: f32, x: f32) -> f32;
}
extern "C" {
    pub fn clampmaxfsel(x: f32, max: f32) -> f32;
}
extern "C" {
    #[doc = " Clip upper bound of x to m (inclusive)"]
    pub fn clipmaxf(x: f32, m: f32) -> f32;
}
extern "C" {
    #[doc = " Clip lower bound of x to m (inclusive)"]
    pub fn clipminf(m: f32, x: f32) -> f32;
}
extern "C" {
    #[doc = " Clip x to min and max (inclusive)"]
    pub fn clipminmaxf(min: f32, x: f32, max: f32) -> f32;
}
extern "C" {
    #[doc = " Clip lower bound of x to 0.f (inclusive)"]
    pub fn clip0f(x: f32) -> f32;
}
extern "C" {
    #[doc = " Clip upper bound of x to 1.f (inclusive)"]
    pub fn clip1f(x: f32) -> f32;
}
extern "C" {
    #[doc = " Clip x to [0.f, 1.f] (inclusive)"]
    pub fn clip01f(x: f32) -> f32;
}
extern "C" {
    #[doc = " Clip lower bound of x to -1.f (inclusive)"]
    pub fn clipm1f(x: f32) -> f32;
}
extern "C" {
    #[doc = " Clip x to [-1.f, 1.f] (inclusive)"]
    pub fn clip1m1f(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" sine approximation, valid for x in [-M_PI, M_PI]\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastsinf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" sine approximation, valid for x in [-M_PI, M_PI]\n @note Adapted from Paul Mineiro's FastFloat\n @note Warning: can be slower than libc version!"]
    pub fn fastersinf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" sine approximation, valid on full x domain\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastsinfullf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" sine approximation, valid on full x domain\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastersinfullf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" cosine approximation, valid for x in [-M_PI, M_PI]\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastcosf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" cosine approximation, valid for x in [-M_PI, M_PI]\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastercosf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" cosine approximation, valid on full x domain\n @note Adapted from Paul Mineiro's FastFloat\n @note Warning: can be slower than libc version!"]
    pub fn fastcosfullf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" cosine approximation, valid on full x domain\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastercosfullf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" tangent approximation, valid for x in [-M_PI_2, M_PI_2]\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fasttanf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" tangent approximation, valid for x in [-M_PI_2, M_PI_2]\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastertanf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" tangent approximation, valid on full x domain, except where tangent diverges.\n @note Adapted from Paul Mineiro's FastFloat\n @note Warning: can be slower than libc version!"]
    pub fn fasttanfullf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" tangent approximation, valid on full x domain, except where tangent diverges.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastertanfullf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" log base 2 approximation, valid for positive x as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastlog2f(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" log base 2 approximation, valid for positive x as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fasterlog2f(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" natural logarithm approximation, valid for positive x as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastlogf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" natural logarithm approximation, valid for positive x as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fasterlogf(x: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" power of 2 approximation, valid for x in [ -126, ... as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastpow2f(p: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" power of 2 approximation, valid for x in [ -126, ... as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fasterpow2f(p: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" x to the power of p approximation\n @note Adapted from Paul Mineiro's FastFloat\n @note Warning: Seems to have divergent segments with discontinuities for some base/exponent combinations"]
    pub fn fastpowf(x: f32, p: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" x to the power of p approximation\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fasterpowf(x: f32, p: f32) -> f32;
}
extern "C" {
    #[doc = " \"Fast\" exponential approximation, valid for x in [ ~ -87, ... as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fastexpf(p: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" exponential approximation, valid for x in [ ~ -87, ... as precision allows.\n @note Adapted from Paul Mineiro's FastFloat"]
    pub fn fasterexpf(p: f32) -> f32;
}
extern "C" {
    #[doc = " atan2 approximation\n @note Adapted from http://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization"]
    pub fn fasteratan2f(y: f32, x: f32) -> f32;
}
extern "C" {
    #[doc = " Hyperbolic tangent approximation\n @note Adapted from http://math.stackexchange.com/questions/107292/rapid-approximation-of-tanhx"]
    pub fn fastertanhf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Another Hyperbolic tangent approximation\n @note Starts diverging from -1,1 beyond ~[-pi, pi]"]
    pub fn fastertanh2f(x: f32) -> f32;
}
extern "C" {
    #[doc = " Amplitude to dB\n @note Will remove low boundary check in future version"]
    pub fn ampdbf(amp: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" Amplitude to dB"]
    pub fn fasterampdbf(amp: f32) -> f32;
}
extern "C" {
    #[doc = " dB to ampltitude"]
    pub fn dbampf(db: f32) -> f32;
}
extern "C" {
    #[doc = " \"Faster\" dB to ampltitude"]
    pub fn fasterdbampf(db: f32) -> f32;
}
extern "C" {
    #[doc = " Linear interpolation"]
    pub fn linintf(fr: f32, x0: f32, x1: f32) -> f32;
}
extern "C" {
    #[doc = " Cosine interpolation"]
    pub fn cosintf(fr: f32, x0: f32, x1: f32) -> f32;
}
extern "C" {
    #[doc = " Buffer-wise Q31 to float conversion"]
    pub fn buf_q31_to_f32(q31: *const q31_t, flt: *mut f32, len: usize);
}
extern "C" {
    #[doc = " Buffer-wise float to Q31 conversion"]
    pub fn buf_f32_to_q31(flt: *const f32, q31: *mut q31_t, len: usize);
}
extern "C" {
    #[doc = " Buffer clear (float version)"]
    pub fn buf_clr_f32(ptr: *mut f32, len: u32);
}
extern "C" {
    #[doc = " Buffer clear (32bit unsigned integer version)."]
    pub fn buf_clr_u32(ptr: *mut u32, len: usize);
}
extern "C" {
    #[doc = " Buffer copy (float version)."]
    pub fn buf_cpy_f32(src: *const f32, dst: *mut f32, len: usize);
}
extern "C" {
    #[doc = " Buffer copy (32bit unsigned integer version)."]
    pub fn buf_cpy_u32(src: *const u32, dst: *mut u32, len: usize);
}
extern "C" {
    #[doc = " Current platform"]
    pub static k_osc_api_platform: u32;
}
extern "C" {
    #[doc = " Current API version"]
    pub static k_osc_api_version: u32;
}
extern "C" {
    #[doc = " Get MCU hash\n\n @return  A MCU specific \"unique\" hash."]
    pub fn osc_mcu_hash() -> u32;
}
extern "C" {
    pub static midi_to_hz_lut_f: [f32; 152usize];
}
extern "C" {
    #[doc = " Get Hertz value for note\n\n @param note Note in [0-151] range.\n @return     Corresponding Hertz value."]
    pub fn osc_notehzf(note: u8) -> f32;
}
extern "C" {
    #[doc = " Get floating point phase increment for given note and fine modulation\n\n @param note Note in [0-151] range, mod in [0-255] range.\n @return     Corresponding 0-1 phase increment in floating point."]
    pub fn osc_w0f_for_note(note: u8, mod_: u8) -> f32;
}
extern "C" {
    pub static wt_sine_lut_f: [f32; 129usize];
}
extern "C" {
    #[doc = " Lookup value of sin(2*pi*x).\n\n @param   x  Phase ratio\n @return     Result of sin(2*pi*x)."]
    pub fn osc_sinf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of cos(2*pi*x) in [0, 1.0] range.\n\n @param   x  Value in [0, 1.0].\n @return     Result of cos(2*pi*x)."]
    pub fn osc_cosf(x: f32) -> f32;
}
extern "C" {
    pub static wt_saw_notes: [u8; 7usize];
}
extern "C" {
    pub static wt_saw_lut_f: [f32; 903usize];
}
extern "C" {
    #[doc = " Sawtooth wave lookup.\n\n @param   x  Phase in [0, 1.0].\n @return     Wave sample."]
    pub fn osc_sawf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Band-limited sawtooth wave lookup.\n\n @param   x     Phase in [0, 1.0].\n @param   idx   Wave index in [0,6].\n @return        Wave sample."]
    pub fn osc_bl_sawf(x: f32, idx: u8) -> f32;
}
extern "C" {
    #[doc = " Band-limited sawtooth wave lookup. (interpolated version)\n\n @param   x     Phase in [0, 1.0].\n @param   idx   Fractional wave index in [0,6].\n @return        Wave sample."]
    pub fn osc_bl2_sawf(x: f32, idx: f32) -> f32;
}
extern "C" {
    #[doc = " Get band-limited sawtooth wave index for note.\n\n @param note Fractional note in [0-151] range.\n @return     Corresponding band-limited wave fractional index in [0-6]."]
    pub fn osc_bl_saw_idx(note: f32) -> f32;
}
extern "C" {
    pub static wt_sqr_notes: [u8; 7usize];
}
extern "C" {
    pub static wt_sqr_lut_f: [f32; 903usize];
}
extern "C" {
    #[doc = " Square wave lookup.\n\n @param   x  Phase in [0, 1.0].\n @return     Wave sample.\n @note Not checking input, caller responsible for bounding x."]
    pub fn osc_sqrf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Band-limited square wave lookup.\n\n @param   x     Phase in [0, 1.0].\n @param   idx   Wave index in [0,6].\n @return        Wave sample.\n @note Not checking input, caller responsible for bounding x and idx."]
    pub fn osc_bl_sqrf(x: f32, idx: u8) -> f32;
}
extern "C" {
    #[doc = " Band-limited square wave lookup. (interpolated version).\n\n @param   x     Phase in [0, 1.0].\n @param   idx   Fractional wave index in [0,6].\n @return        Wave sample.\n @note Not checking input, caller responsible for bounding x and idx."]
    pub fn osc_bl2_sqrf(x: f32, idx: f32) -> f32;
}
extern "C" {
    #[doc = " Get band-limited square wave index for note.\n\n @param note Fractional note in [0-151] range.\n @return     Corresponding band-limited wave fractional index in [0-6]."]
    pub fn osc_bl_sqr_idx(note: f32) -> f32;
}
extern "C" {
    pub static wt_par_notes: [u8; 7usize];
}
extern "C" {
    pub static wt_par_lut_f: [f32; 903usize];
}
extern "C" {
    #[doc = " Parabolic wave lookup.\n\n @param   x  Phase in [0, 1.0].\n @return     Wave sample.\n @note Not checking input, caller responsible for bounding x."]
    pub fn osc_parf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Band-limited parabolic wave lookup.\n\n @param   x     Phase in [0, 1.0].\n @param   idx   Wave index in [0,6].\n @return        Wave sample.\n @note Not checking input, caller responsible for bounding x and idx."]
    pub fn osc_bl_parf(x: f32, idx: u8) -> f32;
}
extern "C" {
    #[doc = " Band-limited parabolic wave lookup. (interpolated version)\n\n @param   x     Phase in [0, 1.0].\n @param   idx   Fractional wave index in [0,6].\n @return        Wave sample.\n @note Not checking input, caller responsible for bounding x and idx."]
    pub fn osc_bl2_parf(x: f32, idx: f32) -> f32;
}
extern "C" {
    #[doc = " Get band-limited parabolic wave index for note.\n\n @param note Fractional note in [0-151] range.\n @return     Corresponding band-limited wave fractional index in [0-6]."]
    pub fn osc_bl_par_idx(note: f32) -> f32;
}
extern "C" {
    pub static wavesA: [*const f32; 16usize];
}
extern "C" {
    pub static wavesB: [*const f32; 16usize];
}
extern "C" {
    pub static wavesC: [*const f32; 14usize];
}
extern "C" {
    pub static wavesD: [*const f32; 13usize];
}
extern "C" {
    pub static wavesE: [*const f32; 15usize];
}
extern "C" {
    pub static wavesF: [*const f32; 16usize];
}
extern "C" {
    pub fn osc_wave_scanf(w: *const f32, x: f32) -> f32;
}
extern "C" {
    pub fn osc_wave_scanuf(w: *const f32, x: u32) -> f32;
}
extern "C" {
    pub static log_lut_f: [f32; 257usize];
}
extern "C" {
    #[doc = " Lookup value of log(x) in [0.00001, 1.0] range.\n\n @param   x  Value in [0.00001, 1.0].\n @return     Result of log(x).\n @note Not checking input, caller responsible for bounding x."]
    pub fn osc_logf(x: f32) -> f32;
}
extern "C" {
    pub static tanpi_lut_f: [f32; 257usize];
}
extern "C" {
    #[doc = " Lookup value of tan(pi*x) in [0.0001, 0.49] range.\n\n @param   x  Value in [0.0001, 0.49].\n @return     Result of tan(pi*x).\n @note Not checking input, caller responsible for bounding x."]
    pub fn osc_tanpif(x: f32) -> f32;
}
extern "C" {
    pub static sqrtm2log_lut_f: [f32; 257usize];
}
extern "C" {
    #[doc = " Lookup value of sqrt(-2*log(x)) in [0.005, 1.0] range.\n\n @param   x  Value in [0.005, 1.0].\n @return     Result of sqrt(-2*log(x)).\n @note Not checking input, caller responsible for bounding x."]
    pub fn osc_sqrtm2logf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Soft clip\n\n @param   c  Coefficient in [0, 1/3].\n @param   x  Value in (-inf, +inf).\n @return     Clipped value in [-(1-c), (1-c)]."]
    pub fn osc_softclipf(c: f32, x: f32) -> f32;
}
extern "C" {
    pub static cubicsat_lut_f: [f32; 129usize];
}
extern "C" {
    #[doc = " Cubic saturation.\n\n @param   x  Value in [-1.0, 1.0].\n @return     Cubic curve above 0.42264973081, gain: 1.2383127573"]
    pub fn osc_sat_cubicf(x: f32) -> f32;
}
extern "C" {
    pub static schetzen_lut_f: [f32; 129usize];
}
extern "C" {
    #[doc = " Schetzen saturation.\n\n @param   x  Value in [-1.0, 1.0].\n @return     Saturated value."]
    pub fn osc_sat_schetzenf(x: f32) -> f32;
}
extern "C" {
    pub static bitres_lut_f: [f32; 129usize];
}
extern "C" {
    #[doc = " Bit depth scaling table\n\n @param   x  Value in [0, 1.0].\n @return     Quantization scaling factor.\n @note       Fractional bit depth, exponentially mapped, 1 to 24 bits."]
    pub fn osc_bitresf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Random integer\n\n @return     Value in [0, UINT_MAX].\n @note       Generated with Park-Miller-Carta"]
    pub fn osc_rand() -> u32;
}
extern "C" {
    #[doc = " Gaussian white noise\n\n @return     Value in [-1.0, 1.0]."]
    pub fn osc_white() -> f32;
}
extern "C" {
    #[doc = " Current platform"]
    pub static k_fx_api_platform: u32;
}
extern "C" {
    #[doc = " Current API version"]
    pub static k_fx_api_version: u32;
}
extern "C" {
    #[doc = " Get MCU hash\n\n @return  A MCU specific \"unique\" hash."]
    pub fn fx_mcu_hash() -> u32;
}
extern "C" {
    #[doc = " Get current tempo as beats per minute as integer\n\n @return  Current integer BPM, multiplied by 10 to allow 1 decimal precision"]
    pub fn fx_get_bpm() -> u16;
}
extern "C" {
    #[doc = " Get current tempo as beats per minute as floating point\n\n @return  Current floating point BPM"]
    pub fn fx_get_bpmf() -> f32;
}
extern "C" {
    #[doc = " Lookup value of sin(2*pi*x).\n\n @param   x  Phase ratio\n @return     Result of sin(2*pi*x)."]
    pub fn fx_sinf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of sin(2*pi*x) in [0, 1.0] range.\n\n @param   x  Phase ratio.\n @return     Result of sin(2*pi*x)."]
    pub fn fx_sinuf(x: u32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of cos(2*pi*x) in [0, 1.0] range.\n\n @param   x  Value in [0, 1.0].\n @return     Result of cos(2*pi*x)."]
    pub fn fx_cosf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of cos(2*pi*x) in [0, 1.0] range.\n\n @param   x  Phase ratio.\n @return     Result of sin(2*pi*x)."]
    pub fn fx_cosuf(x: u32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of log(x) in [0.00001, 1.0] range.\n\n @param   x  Value in [0.00001, 1.0].\n @return     Result of log(x).\n @note Not checking input, caller responsible for bounding x."]
    pub fn fx_logf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of tan(pi*x) in [0.0001, 0.49] range.\n\n @param   x  Value in [0.0001, 0.49].\n @return     Result of tan(pi*x).\n @note Not checking input, caller responsible for bounding x."]
    pub fn fx_tanpif(x: f32) -> f32;
}
extern "C" {
    #[doc = " Lookup value of sqrt(-2*log(x)) in [0.005, 1.0] range.\n\n @param   x  Value in [0.005, 1.0].\n @return     Result of sqrt(-2*log(x)).\n @note Not checking input, caller responsible for bounding x."]
    pub fn fx_sqrtm2logf(x: f32) -> f32;
}
extern "C" {
    pub static pow2_lut_f: [f32; 257usize];
}
extern "C" {
    #[doc = " Lookup value of 2^k for k in [0, 3.0] range.\n\n @param   x  Value in [0, 3.0].\n @return     Result of 2^k.\n @note Not checking input, caller responsible for bounding x."]
    pub fn fx_pow2f(x: f32) -> f32;
}
extern "C" {
    #[doc = " Soft clip\n\n @param   c  Coefficient in [0, 1/3].\n @param   x  Value in (-inf, +inf).\n @return     Clipped value in [-(1-c), (1-c)]."]
    pub fn fx_softclipf(c: f32, x: f32) -> f32;
}
extern "C" {
    #[doc = " Cubic saturation.\n\n @param   x  Value in [-1.0, 1.0].\n @return     Cubic curve above 0.42264973081, gain: 1.2383127573"]
    pub fn fx_sat_cubicf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Schetzen saturation.\n\n @param   x  Value in [-1.0, 1.0].\n @return     Saturated value."]
    pub fn fx_sat_schetzenf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Bit depth scaling table\n\n @param   x  Value in [0, 1.0].\n @return     Quantization scaling factor.\n @note       Fractional bit depth, exponentially mapped, 1 to 24 bits."]
    pub fn fx_bitresf(x: f32) -> f32;
}
extern "C" {
    #[doc = " Random integer\n\n @return     Value in [0, UINT_MAX].\n @note       Generated with Park-Miller-Carta"]
    pub fn fx_rand() -> u32;
}
extern "C" {
    #[doc = " Gaussian white noise\n\n @return     Value in [-1.0, 1.0]."]
    pub fn fx_white() -> f32;
}
#[doc = " Dummy category, may be used in future."]
pub const k_unit_module_global: _bindgen_ty_1 = 0;
#[doc = " Modulation effects"]
pub const k_unit_module_modfx: _bindgen_ty_1 = 1;
#[doc = " Delay effects"]
pub const k_unit_module_delfx: _bindgen_ty_1 = 2;
#[doc = " Reverb effects"]
pub const k_unit_module_revfx: _bindgen_ty_1 = 3;
#[doc = " Oscillators"]
pub const k_unit_module_osc: _bindgen_ty_1 = 4;
#[doc = " Synth voices"]
pub const k_unit_module_synth: _bindgen_ty_1 = 5;
#[doc = " Master effects"]
pub const k_unit_module_masterfx: _bindgen_ty_1 = 6;
#[doc = " Master effects"]
pub const k_num_unit_modules: _bindgen_ty_1 = 7;
#[doc = " Unit module categories."]
pub type _bindgen_ty_1 = core::ffi::c_uint;
pub const k_unit_target_prologue: _bindgen_ty_2 = 256;
pub const k_unit_target_prologue_global: _bindgen_ty_2 = 256;
pub const k_unit_target_prologue_modfx: _bindgen_ty_2 = 257;
pub const k_unit_target_prologue_delfx: _bindgen_ty_2 = 258;
pub const k_unit_target_prologue_revfx: _bindgen_ty_2 = 259;
pub const k_unit_target_prologue_osc: _bindgen_ty_2 = 260;
#[doc = " prologue specific platform/module pairs.\n Passed to user code via initialization callback."]
pub type _bindgen_ty_2 = core::ffi::c_uint;
pub const k_unit_target_miniloguexd: _bindgen_ty_3 = 512;
pub const k_unit_target_miniloguexd_global: _bindgen_ty_3 = 512;
pub const k_unit_target_miniloguexd_modfx: _bindgen_ty_3 = 513;
pub const k_unit_target_miniloguexd_delfx: _bindgen_ty_3 = 514;
pub const k_unit_target_miniloguexd_revfx: _bindgen_ty_3 = 515;
pub const k_unit_target_miniloguexd_osc: _bindgen_ty_3 = 516;
#[doc = " minilogue-xd specific platform/module pairs.\n Passed to user code via initialization callback."]
pub type _bindgen_ty_3 = core::ffi::c_uint;
pub const k_unit_target_nutektdigital: _bindgen_ty_4 = 768;
pub const k_unit_target_nutektdigital_global: _bindgen_ty_4 = 768;
pub const k_unit_target_nutektdigital_modfx: _bindgen_ty_4 = 769;
pub const k_unit_target_nutektdigital_delfx: _bindgen_ty_4 = 770;
pub const k_unit_target_nutektdigital_revfx: _bindgen_ty_4 = 771;
pub const k_unit_target_nutektdigital_osc: _bindgen_ty_4 = 772;
#[doc = " Nu:Tekt NTS-1 digital specific platform/module pairs.\n Passed to user code via initialization callback."]
pub type _bindgen_ty_4 = core::ffi::c_uint;
pub const k_unit_target_nts1: _bindgen_ty_5 = 768;
pub const k_unit_target_nts1_global: _bindgen_ty_5 = 768;
pub const k_unit_target_nts1_modfx: _bindgen_ty_5 = 769;
pub const k_unit_target_nts1_delfx: _bindgen_ty_5 = 770;
pub const k_unit_target_nts1_revfx: _bindgen_ty_5 = 771;
pub const k_unit_target_nts1_osc: _bindgen_ty_5 = 772;
#[doc = " Aliases for Nu:Tekt NTS-1 digital specific platform/module pairs."]
pub type _bindgen_ty_5 = core::ffi::c_uint;
pub const k_unit_target_drumlogue: _bindgen_ty_6 = 1024;
pub const k_unit_target_drumlogue_delfx: _bindgen_ty_6 = 1026;
pub const k_unit_target_drumlogue_revfx: _bindgen_ty_6 = 1027;
pub const k_unit_target_drumlogue_synth: _bindgen_ty_6 = 1029;
pub const k_unit_target_drumlogue_masterfx: _bindgen_ty_6 = 1030;
#[doc = " drumlogue specific platform/module pairs.\n Passed to user code via initialization callback."]
pub type _bindgen_ty_6 = core::ffi::c_uint;
pub const k_unit_target_nts1_mkii: _bindgen_ty_7 = 1280;
pub const k_unit_target_nts1_mkii_global: _bindgen_ty_7 = 1280;
pub const k_unit_target_nts1_mkii_modfx: _bindgen_ty_7 = 1281;
pub const k_unit_target_nts1_mkii_delfx: _bindgen_ty_7 = 1282;
pub const k_unit_target_nts1_mkii_revfx: _bindgen_ty_7 = 1283;
pub const k_unit_target_nts1_mkii_osc: _bindgen_ty_7 = 1284;
#[doc = " Nu:Tekt NTS-1 digital MKII specific platform/module pairs.\n Passed to user code via initialization callback."]
pub type _bindgen_ty_7 = core::ffi::c_uint;
pub const k_unit_api_1_0_0: _bindgen_ty_8 = 65536;
pub const k_unit_api_1_1_0: _bindgen_ty_8 = 65792;
pub const k_unit_api_2_0_0: _bindgen_ty_8 = 131072;
#[doc = " Valid API versions.\n  Major: breaking changes (7bits, cap to 99)\n  Minor: additions only   (7bits, cap to 99)\n  Sub:   bugfixes only    (7bits, cap to 99)"]
pub type _bindgen_ty_8 = core::ffi::c_uint;
#[doc = " Base type for runtime contexts.\n Currently void as there are no common contextual fields accross unit types."]
pub type unit_runtime_base_context_t = core::ffi::c_void;
#[doc = " SDRAM allocator callback type\n\n The callback is used to allocate memory in a given unit runtime's dedicated SDRAM area.\n \\param size Size in bytes of desired memory allocation.\n \\return     Pointer to allocated memory area, or NULL if unsucessful."]
pub type unit_runtime_sdram_alloc_ptr =
    ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut u8>;
#[doc = " SDRAM deallocation callback type\n\n The callback is used to deallocate memory from the runtime's dedicated SDRAM area.\n \\param mem Pointer to memory area previously allocated via a corresponsding unit_runtime_sdram_alloc_ptr callback."]
pub type unit_runtime_sdram_free_ptr = ::core::option::Option<unsafe extern "C" fn(mem: *const u8)>;
#[doc = " SDRAM allocation availability callback type\n\n The callback is used to verify the amount of allocatable memory in the runtime's dedicated SDRAM area.\n \\return Size in bytes of the allocatable memory."]
pub type unit_runtime_sdram_avail_ptr = ::core::option::Option<unsafe extern "C" fn() -> usize>;
#[doc = " Runtime hooks.\n Passed from the unit runtime to the unit during initialization to provide access to runtime APIs that are not known at compile time.\n Note: Member fields will vary from platform to platform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unit_runtime_hooks {
    pub runtime_context: *const unit_runtime_base_context_t,
    #[doc = " Ref. to contextual data exposed by the runtime. (Req. cast to appropriate module-specific type)"]
    pub sdram_alloc: unit_runtime_sdram_alloc_ptr,
    #[doc = " SDRAM allocation callback."]
    pub sdram_free: unit_runtime_sdram_free_ptr,
    #[doc = " SDRAM deallocation callback."]
    pub sdram_avail: unit_runtime_sdram_avail_ptr,
}
#[test]
fn bindgen_test_layout_unit_runtime_hooks() {
    const UNINIT: ::core::mem::MaybeUninit<unit_runtime_hooks> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unit_runtime_hooks>(),
        16usize,
        concat!("Size of: ", stringify!(unit_runtime_hooks))
    );
    assert_eq!(
        ::core::mem::align_of::<unit_runtime_hooks>(),
        4usize,
        concat!("Alignment of ", stringify!(unit_runtime_hooks))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).runtime_context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_hooks),
            "::",
            stringify!(runtime_context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdram_alloc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_hooks),
            "::",
            stringify!(sdram_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdram_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_hooks),
            "::",
            stringify!(sdram_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdram_avail) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_hooks),
            "::",
            stringify!(sdram_avail)
        )
    );
}
#[doc = " Runtime hooks.\n Passed from the unit runtime to the unit during initialization to provide access to runtime APIs that are not known at compile time.\n Note: Member fields will vary from platform to platform"]
pub type unit_runtime_hooks_t = unit_runtime_hooks;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct unit_runtime_desc {
    pub target: u32,
    #[doc = " Target platform/module pair corresponding to runtime."]
    pub api: u32,
    #[doc = " API version used by runtime."]
    pub samplerate: u32,
    #[doc = " Sample rate used by runtime."]
    pub frames_per_buffer: u16,
    #[doc = " Frames per buffer used by runtime in render calls."]
    pub input_channels: u8,
    #[doc = " Number of input channels in render calls."]
    pub output_channels: u8,
    #[doc = " Number of output channels in render calls."]
    pub hooks: unit_runtime_hooks_t,
}
#[test]
fn bindgen_test_layout_unit_runtime_desc() {
    const UNINIT: ::core::mem::MaybeUninit<unit_runtime_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unit_runtime_desc>(),
        32usize,
        concat!("Size of: ", stringify!(unit_runtime_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<unit_runtime_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(unit_runtime_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frames_per_buffer) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(frames_per_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_channels) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(input_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_channels) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(output_channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_desc),
            "::",
            stringify!(hooks)
        )
    );
}
pub type unit_runtime_desc_t = unit_runtime_desc;
pub const k_unit_param_type_none: _bindgen_ty_9 = 0;
#[doc = " Describes a typeless value. The value will be displayed as is, while taking into account the fractional part."]
pub const k_unit_param_type_percent: _bindgen_ty_9 = 1;
#[doc = " Describe a percent value."]
pub const k_unit_param_type_db: _bindgen_ty_9 = 2;
#[doc = " Describes a decibel value."]
pub const k_unit_param_type_cents: _bindgen_ty_9 = 3;
#[doc = " Describes a pitch cents value."]
pub const k_unit_param_type_semi: _bindgen_ty_9 = 4;
#[doc = " Describes a pitch semitone value."]
pub const k_unit_param_type_oct: _bindgen_ty_9 = 5;
#[doc = " Describes an octave offset value."]
pub const k_unit_param_type_hertz: _bindgen_ty_9 = 6;
#[doc = " Describes a Hertz value."]
pub const k_unit_param_type_khertz: _bindgen_ty_9 = 7;
#[doc = " Describes a kilo Hertz value."]
pub const k_unit_param_type_bpm: _bindgen_ty_9 = 8;
#[doc = " Describes a beat per minute value."]
pub const k_unit_param_type_msec: _bindgen_ty_9 = 9;
#[doc = " Describes a milliseconds value."]
pub const k_unit_param_type_sec: _bindgen_ty_9 = 10;
#[doc = " Describes a seconds value."]
pub const k_unit_param_type_enum: _bindgen_ty_9 = 11;
#[doc = " Describes a numerical enumeration value. If the value minimum is set to 0, the value will be incremented by 1 when displayed."]
pub const k_unit_param_type_strings: _bindgen_ty_9 = 12;
#[doc = " Describes a value with custom string representation. The numerical value will be passed in a call to unit_get_param_str_value(..) in order to obtain the string representation."]
pub const k_unit_param_type_reserved0: _bindgen_ty_9 = 13;
#[doc = " Reserved value unused on this platform."]
pub const k_unit_param_type_drywet: _bindgen_ty_9 = 14;
#[doc = " Describes a dry/wet value. Negative values will be prepended with D for dry, positive values with W for wet, and zero value replaced with BALN to indicate a balanced mix."]
pub const k_unit_param_type_pan: _bindgen_ty_9 = 15;
#[doc = " Describes a stereo pan value. Negative values will be prepended with L for left, positive values with R for right, and zero value replaced with CNTR to indicate centered panning."]
pub const k_unit_param_type_spread: _bindgen_ty_9 = 16;
#[doc = " Describes a stereo spread value. Negative values will be prepended with L for left, positive values with R for right, and zero value replaced with CNTR to indicate no stereo spread."]
pub const k_unit_param_type_onoff: _bindgen_ty_9 = 17;
#[doc = " Describes an on/off toggle value. 0 will be displayed as off, and 1 will be displayed as on."]
pub const k_unit_param_type_midi_note: _bindgen_ty_9 = 18;
#[doc = " Describes a MIDI note value. The numerical note value will be displayed as musical pitches (e.g.: C0, A3)."]
pub const k_unit_param_type_count: _bindgen_ty_9 = 19;
#[doc = " Valid parameter value types.\n Influences how the value is displayed, but can be limited by the display technology used for the current target platform."]
pub type _bindgen_ty_9 = core::ffi::c_uint;
pub const k_unit_param_frac_mode_fixed: _bindgen_ty_10 = 0;
pub const k_unit_param_frac_mode_decimal: _bindgen_ty_10 = 1;
#[doc = " Fractional value interpretations."]
pub type _bindgen_ty_10 = core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct unit_param {
    pub min: i16,
    #[doc = " Minimum value."]
    pub max: i16,
    #[doc = " Maximum value."]
    pub center: i16,
    #[doc = " Logical center value."]
    pub init: i16,
    #[doc = " Initial/default value."]
    pub type_: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Reserved bits. Keep to zero."]
    pub name: [core::ffi::c_char; 22usize],
}
#[test]
fn bindgen_test_layout_unit_param() {
    const UNINIT: ::core::mem::MaybeUninit<unit_param> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unit_param>(),
        32usize,
        concat!("Size of: ", stringify!(unit_param))
    );
    assert_eq!(
        ::core::mem::align_of::<unit_param>(),
        1usize,
        concat!("Alignment of ", stringify!(unit_param))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_param),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_param),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_param),
            "::",
            stringify!(center)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_param),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_param),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_param),
            "::",
            stringify!(name)
        )
    );
}
impl unit_param {
    #[inline]
    pub fn frac(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_frac(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn frac_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frac_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frac: u8,
        frac_mode: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let frac: u8 = unsafe { ::core::mem::transmute(frac) };
            frac as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frac_mode: u8 = unsafe { ::core::mem::transmute(frac_mode) };
            frac_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type unit_param_t = unit_param;
#[doc = " Unit initialization callback type\n\n The callback is called to initialize units immediately after loading them into the runtime.\n \\param desc Pointer to the runtime descriptor. @see unit_runtime_desc_t.\n \\return 0 shall be returned upon successful inialization, otherwise an error code shall be returned. See k_unit_err_* definitions."]
pub type unit_init_func =
    ::core::option::Option<unsafe extern "C" fn(desc: *const unit_runtime_desc_t) -> i8>;
#[doc = " Unit teardown callback type\n\n The callback is called before the unit is unloaded from the runtime environment."]
pub type unit_teardown_func = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Unit reset callback type"]
pub type unit_reset_func = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Unit resume rendering callback type\n\n The callback is called when the unit shall exit suspended state and be ready for its render callback to be called."]
pub type unit_resume_func = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Unit suspend rendering callback type\n\n The callback is called when the unit shall enter suspended state."]
pub type unit_suspend_func = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Unit render callback type\n\n After initialization, and after exiting suspended state, the render callback is called at each audio processing cycle.\n Note that input and output buffers either overlap completely or not at all.\n Input/output channel geometry is determined by the runtime descriptor passed via the initialization callback.\n @see unit_init_func\n @see unit_runtime_desc_t\n\n \\param in     Input audio data buffer pointer.\n \\param out    Output audio data buffer pointer.\n \\param frames Number of audio frames in input and output buffers."]
pub type unit_render_func =
    ::core::option::Option<unsafe extern "C" fn(in_: *const f32, out: *mut f32, frames: u32)>;
#[doc = " Unit get parameter value callback type\n\n After initialization, the callback may be called at any time to obtain the current value of the given parameter.\n\n \\param param_id Parameter identifier.\n \\return Current value of parameter according to value range and format defined in the parameter's descriptor."]
pub type unit_get_param_value_func =
    ::core::option::Option<unsafe extern "C" fn(param_id: u8) -> i32>;
#[doc = " Unit get parameter string value callback type\n\n After initialization, the callback may be called at any time to convert a k_unit_param_type_strings typed parameter's numerical value into a string representation.\n It can be assumed that the string data will have been used or cached by the runtime before the callback is called again.\n\n \\param param_id Parameter identifier.\n \\param value    Numerical value of parameter according to range defined in the parameter's descriptor.\n \\return String representation of value."]
pub type unit_get_param_str_value_func = ::core::option::Option<
    unsafe extern "C" fn(param_id: u8, value: i32) -> *const core::ffi::c_char,
>;
#[doc = " Unit set parameter value callback type\n\n After initialization, the callback may be called at any time to set the current value of the given parameter.\n\n \\param param_id Parameter identifier.\n \\param value    Value of parameter according to value range and format defined in the parameter's descriptor."]
pub type unit_set_param_value_func =
    ::core::option::Option<unsafe extern "C" fn(param_id: u8, value: i32)>;
#[doc = " Unit set tempo callback type\n\n After initialization, the callback may be called at any time to notify the unit of the current master tempo.\n\n \\param tempo Current tempo in UQ16.16 representation (i.e.: fractional part in lower 16 bits)."]
pub type unit_set_tempo_func = ::core::option::Option<unsafe extern "C" fn(tempo: u32)>;
#[doc = " Unit tempo 4ppqn tick callback type\n\n After initialization, the callback may be called at any time to notify the unit of a clock event (4PPQN interval, ie: 16th notes with regards to tempo).\n\n \\param counter Clock event counter since last transport reset."]
pub type unit_tempo_4ppqn_tick_func = ::core::option::Option<unsafe extern "C" fn(counter: u32)>;
#[doc = " Unit note on callback type\n\n After initialization, the callback may be called at any time to notify the unit of a note on event.\n TODO: clarify whether ever called velocity == 0 meaning note off or not\n\n \\param note      Note number following MIDI note numbering semantics.\n \\param velocity  Velocity following MIDI note on message semantics."]
pub type unit_note_on_func = ::core::option::Option<unsafe extern "C" fn(note: u8, velocity: u8)>;
#[doc = " Unit note off callback type\n\n After initialization, the callback may be called at any time to notify the unit of a note off event.\n\n \\param note      Note number following MIDI note numbering semantics."]
pub type unit_note_off_func = ::core::option::Option<unsafe extern "C" fn(arg1: u8)>;
#[doc = " Unit all note off callback type\n\n After initialization, the callback may be called at any time to notify the terminate any pending active notes."]
pub type unit_all_note_off_func = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Unit note off callback type\n\n After initialization, the callback may be called at any time to notify the unit of a pitch bend event.\n\n \\param bend  14-bit MIDI pitch bend value with neutral center at 0x2000. Sensitivity is left at the discretion of the unit."]
pub type unit_pitch_bend_func = ::core::option::Option<unsafe extern "C" fn(bend: u16)>;
#[doc = " Unit channel pressure callback type\n\n After initialization, the callback may be called at any time to notify the unit of a channel pressure event.\n\n \\param pressure 7-bit value pressure amount."]
pub type unit_channel_pressure_func = ::core::option::Option<unsafe extern "C" fn(pressure: u8)>;
#[doc = " Unit channel pressure callback type\n\n After initialization, the callback may be called at any time to notify the unit of an aftertouch event.\n\n \\param note       Note number following MIDI note numbering semantics.\n \\param aftertouch 7-bit value aftertouch amount."]
pub type unit_aftertouch_func =
    ::core::option::Option<unsafe extern "C" fn(note: u8, aftertouch: u8)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct unit_header {
    pub header_size: u32,
    #[doc = " Size of the header."]
    pub target: u32,
    #[doc = " Platform and module pair the unit is targeted for"]
    pub api: u32,
    #[doc = " API version for which the unit was built. See k_unit_api_* above."]
    pub dev_id: u32,
    #[doc = " Developer ID. See https://github.com/korginc/logue-sdk/blob/master/developer_ids.md"]
    pub unit_id: u32,
    #[doc = " ID for this unit. Scoped within the context of a given dev_id."]
    pub version: u32,
    #[doc = " The unit's version following the same major.minor.patch format and rules as the API version"]
    pub name: [core::ffi::c_char; 20usize],
    #[doc = " Unit name."]
    pub reserved0: u32,
    #[doc = " Reserved for future use."]
    pub reserved1: u32,
    #[doc = " Reserved for future use."]
    pub num_params: u32,
    #[doc = " Number of valid parameter descriptors."]
    pub params: [unit_param_t; 11usize],
}
#[test]
fn bindgen_test_layout_unit_header() {
    const UNINIT: ::core::mem::MaybeUninit<unit_header> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unit_header>(),
        408usize,
        concat!("Size of: ", stringify!(unit_header))
    );
    assert_eq!(
        ::core::mem::align_of::<unit_header>(),
        1usize,
        concat!("Alignment of ", stringify!(unit_header))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(dev_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unit_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(unit_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_params) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(num_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_header),
            "::",
            stringify!(params)
        )
    );
}
pub type unit_header_t = unit_header;
pub const k_unit_err_none: _bindgen_ty_11 = 0;
pub const k_unit_err_target: _bindgen_ty_11 = -1;
pub const k_unit_err_api_version: _bindgen_ty_11 = -2;
pub const k_unit_err_samplerate: _bindgen_ty_11 = -4;
pub const k_unit_err_geometry: _bindgen_ty_11 = -8;
pub const k_unit_err_memory: _bindgen_ty_11 = -16;
pub const k_unit_err_undef: _bindgen_ty_11 = -32;
#[doc = " Result/error codes expected from initilization callback."]
pub type _bindgen_ty_11 = core::ffi::c_int;
extern "C" {
    pub static unit_header: unit_header_t;
}
pub const k_unit_delfx_fixed_param_time: _bindgen_ty_12 = 0;
pub const k_unit_delfx_fixed_param_depth: _bindgen_ty_12 = 1;
pub const k_unit_delfx_fixed_param_mix: _bindgen_ty_12 = 2;
pub const k_num_unit_delfx_fixed_param_id: _bindgen_ty_12 = 3;
#[doc = " Exposed parameters with fixed/direct UI controls."]
pub type _bindgen_ty_12 = core::ffi::c_uint;
pub const k_unit_modfx_fixed_param_time: _bindgen_ty_13 = 0;
pub const k_unit_modfx_fixed_param_depth: _bindgen_ty_13 = 1;
pub const k_num_unit_modfx_fixed_param_id: _bindgen_ty_13 = 2;
#[doc = " Exposed parameters with fixed/direct UI controls."]
pub type _bindgen_ty_13 = core::ffi::c_uint;
pub const k_runtime_osc_input_unused: _bindgen_ty_14 = 0;
pub const k_runtime_osc_input_used: _bindgen_ty_14 = 1;
#[doc = " Oscillator input usage states"]
pub type _bindgen_ty_14 = core::ffi::c_uint;
#[doc = " Pointer to notify_input_usage(uint8_t usage), used to notify the runtime that oscillator is using the audio input or not.\n Note: the runtime assumes audio input is unused by default"]
pub type unit_runtime_osc_notify_input_usage_ptr =
    ::core::option::Option<unsafe extern "C" fn(arg1: u8)>;
#[doc = " Oscillator specific unit runtime context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unit_runtime_osc_context {
    pub shape_lfo: i32,
    pub pitch: u16,
    pub cutoff: u16,
    pub resonance: u16,
    pub amp_eg_phase: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub notify_input_usage: unit_runtime_osc_notify_input_usage_ptr,
}
#[test]
fn bindgen_test_layout_unit_runtime_osc_context() {
    const UNINIT: ::core::mem::MaybeUninit<unit_runtime_osc_context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unit_runtime_osc_context>(),
        16usize,
        concat!("Size of: ", stringify!(unit_runtime_osc_context))
    );
    assert_eq!(
        ::core::mem::align_of::<unit_runtime_osc_context>(),
        4usize,
        concat!("Alignment of ", stringify!(unit_runtime_osc_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shape_lfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_osc_context),
            "::",
            stringify!(shape_lfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_osc_context),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cutoff) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_osc_context),
            "::",
            stringify!(cutoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resonance) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_osc_context),
            "::",
            stringify!(resonance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).amp_eg_phase) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_osc_context),
            "::",
            stringify!(amp_eg_phase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_input_usage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(unit_runtime_osc_context),
            "::",
            stringify!(notify_input_usage)
        )
    );
}
impl unit_runtime_osc_context {
    #[inline]
    pub fn amp_eg_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_amp_eg_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn padding0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_padding0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(amp_eg_state: u8, padding0: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let amp_eg_state: u8 = unsafe { ::core::mem::transmute(amp_eg_state) };
            amp_eg_state as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let padding0: u8 = unsafe { ::core::mem::transmute(padding0) };
            padding0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Oscillator specific unit runtime context."]
pub type unit_runtime_osc_context_t = unit_runtime_osc_context;
pub const k_unit_osc_fixed_param_shape: _bindgen_ty_15 = 0;
pub const k_unit_osc_fixed_param_altshape: _bindgen_ty_15 = 1;
pub const k_num_unit_osc_fixed_param_id: _bindgen_ty_15 = 2;
#[doc = " Exposed parameters with fixed/direct UI controls."]
pub type _bindgen_ty_15 = core::ffi::c_uint;
pub const k_unit_revfx_fixed_param_time: _bindgen_ty_16 = 0;
pub const k_unit_revfx_fixed_param_depth: _bindgen_ty_16 = 1;
pub const k_unit_revfx_fixed_param_mix: _bindgen_ty_16 = 2;
pub const k_num_unit_revfx_fixed_param_id: _bindgen_ty_16 = 3;
#[doc = " Exposed parameters with fixed/direct UI controls."]
pub type _bindgen_ty_16 = core::ffi::c_uint;
